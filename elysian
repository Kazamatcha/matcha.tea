getgenv().Elysian = {
    ['Camlock'] = {
        ['Manual Prediction'] = 0.1475,
        ['Auto Prediction'] = {
            ['Enabled'] = true,
            ['Ping'] = {
                ['20'] = 0.10036,
                ['30'] = 0.1130,
                ['40'] = 0.13544,
                ['50'] = 0.1357,
                ['60'] = 0.13598,
                ['70'] = 0.13892,
                ['80'] = 0.1403,
                ['90'] = 0.1446,
                ['100'] = 0.1475,
                ['120'] = 0.141199,
                ['130'] = 0.1345,
                ['140'] = 0.141199,
                ['150'] = 0.125333,
                ['160'] = 0.16,
                ['170'] = 0.1652131,
                ['180'] = 0.15
            }
        },
        ['Smoothing'] = {
            ['Enabled'] = false,
            ['Value'] = 0.013
        },
        ['Offset'] = {
            ['Jump'] = -1,
            ['Fall'] = -1,
        },
        ['Auto Air Shoot'] = true,
        ['Airshot Function'] = {
            ['Enabled'] = true,
            ['Part'] = "LowerTorso"
        },
        ['Target Part'] = "Head",
        ['Checks'] = {
            ['KO'] = true,
            ['Grab'] = true,
            ['Wall'] = true
        }
    },
    ['TargetStats'] = true,
    ['HvH'] = {
        ['Target Strafe'] = {
            ['Enabled'] = true,
            ['Speed'] = 100,
            ['Distance'] = 10,
            ['Height'] = 7,
        },
        ['Walkspeed'] = {
            ['Enabled'] = true,
            ['WalkSpeed'] = 200,
            ['JumpPower'] = 55,
            ['DefaultWalkSpeed'] = 18,
            ['DefaultJumpPower'] = 55
        }
    },
    ['Desync'] = {
        ['Enabled'] = false,
        ['Mode'] = "DestroyCheaters",
        ['TeleportCFrame'] = CFrame.new(0, 0, 0),
        ['OldPosition'] = nil,
        ['VoidSpamActive'] = false,
        ['ToggleEnabled'] = false
    }
}

local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")

local Locking = false
local Plr = nil
local strafing = false
local walkspeedEnabled = false
local auto_shooting = false

local playerData = {}
local SMOOTHNESS_FACTOR = 2

local desync_setback = Instance.new("Part")
desync_setback.Name = "Desync Setback"
desync_setback.Parent = workspace
desync_setback.Size = Vector3.new(2, 2, 1)
desync_setback.CanCollide = false
desync_setback.Anchored = true
desync_setback.Transparency = 1



local function GetEvent()
    for _, v in pairs(game.ReplicatedStorage:GetChildren()) do
        if v.Name == "MainEvent" or v.Name == "Bullets" or v.Name == ".gg/untitledhood" or v.Name == "Remote" or v.Name == "MAINEVENT" or v.Name == ".gg/flamehood" then
            return v
        end
    end
end

local function GetArgs()
    local PlaceId = game.PlaceId
    if PlaceId == 2788229376 or PlaceId == 4106313503 or PlaceId == 11143225577 or PlaceId == 17319408836 or PlaceId == 18110728826 then
        return "UpdateMousePosI"
    elseif PlaceId == 5602055394 or PlaceId == 7951883376 then
        return "MousePos"
    elseif PlaceId == 10100958808 or PlaceId == 12645617354 or PlaceId == 14171242539 or PlaceId == 14412436145 or PlaceId == 14412355918 or PlaceId == 14413720089 or PlaceId == 17403265390 or PlaceId == 17403166075 or PlaceId == 17403262882 or PlaceId == 15186202290 or PlaceId == 15763494605 then
        return "MOUSE"
    elseif PlaceId == 9825515356 then
        return "MousePosUpdate"
    elseif PlaceId == 15166543806 then
        return "MoonUpdateMousePos"
    elseif PlaceId == 16033173781 or PlaceId == 7213786345 then
        return "UpdateMousePosI"
    else
        return "UpdateMousePos"
    end
end

local mainEvent = GetEvent()

function GetClosestToCenter()
    local closestDist = math.huge
    local closestPlr = nil
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    
    for _, v in ipairs(players:GetPlayers()) do
        if v ~= client and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            local screenPos, onScreen = camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
            if onScreen then
                local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                if distToCenter < closestDist then
                    closestPlr = v
                    closestDist = distToCenter
                end
            end
        end
    end
    return closestPlr
end

local function isValidTarget(plr)
    if not plr or not plr.Character then
        return false
    end
    
    local config = getgenv().Elysian['Camlock']
    local checks = config['Checks']
    
    -- Da Hood-specific KO and Grab checks
    if checks['KO'] or checks['Grab'] then
        local hum = plr.Character:FindFirstChildOfClass("Humanoid")
        if not hum or hum.Health <= 0 then
            return false
        end

        local be = plr.Character:FindFirstChild("BodyEffects")
        if be then
            if checks['KO'] then
                local ko = be:FindFirstChild("K.O")
                if ko and ko.Value then
                    return false
                end
            end
            if checks['Grab'] then
                local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
                if grabbed and grabbed.Value then
                    return false
                end
            end
        end
    end
    
    -- Wall Check: Raycast to ensure line of sight
    if checks['Wall'] then
        local part = plr.Character:FindFirstChild(config['Target Part']) or plr.Character:FindFirstChild("HumanoidRootPart")
        if part then
            local origin = camera.CFrame.Position
            local direction = (part.Position - origin)
            local raycastParams = RaycastParams.new()
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            raycastParams.FilterDescendantsInstances = {client.Character}
            local raycastResult = workspace:Raycast(origin, direction, raycastParams)
            if not raycastResult or not raycastResult.Instance:IsDescendantOf(plr.Character) then
                return false
            end
        end
    end
    
    return true
end

local function getPart()
    if not Plr or not Plr.Character or not isValidTarget(Plr) then
        return nil
    end

    local humanoid = Plr.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return nil
    end

    if humanoid:GetState() == Enum.HumanoidStateType.Freefall and getgenv().Elysian['Camlock']['Airshot Function']['Enabled'] then
        local airshotPart = Plr.Character:FindFirstChild(getgenv().Elysian['Camlock']['Airshot Function']['Part'])
        if airshotPart then
            return airshotPart
        end
    end

    local targetPart = Plr.Character:FindFirstChild(getgenv().Elysian['Camlock']['Target Part'])
    if targetPart then
        return targetPart
    end

    return Plr.Character:FindFirstChild("HumanoidRootPart")
end

local function getPredictionValue()
    if getgenv().Elysian['Camlock']['Auto Prediction']['Enabled'] then
        local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local pingTable = getgenv().Elysian['Camlock']['Auto Prediction']['Ping']
        
        for i = ping, 0, -1 do
            if pingTable[tostring(i)] then
                return pingTable[tostring(i)]
            end
        end
        
        return pingTable['100'] or 0.1475
    else
        return getgenv().Elysian['Camlock']['Manual Prediction']
    end
end

local function calculatePosition(victim, velocity)
    local prediction = getPredictionValue()
    local jumpOffset = getgenv().Elysian['Camlock']['Offset']['Jump']
    local fallOffset = getgenv().Elysian['Camlock']['Offset']['Fall']
    
    local playerDataEntry = playerData[victim.Parent.Parent]
    if not playerDataEntry then
        playerDataEntry = {
            SmoothedVelocity = velocity
        }
        playerData[victim.Parent.Parent] = playerDataEntry
    end
    
    playerDataEntry.SmoothedVelocity = playerDataEntry.SmoothedVelocity:Lerp(velocity, 0.5)
    
    local pos = victim.Position + playerDataEntry.SmoothedVelocity * prediction

    if victim.Parent and victim.Parent:FindFirstChild("Humanoid") then
        local humanoid = victim.Parent.Humanoid
        if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            pos = pos + Vector3.new(0, jumpOffset, 0)
        elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            pos = pos + Vector3.new(0, fallOffset, 0)
        end
    end

    return pos
end

local function CharAdded()
    if Locking and Plr and Plr.Character and playerData[Plr] and isValidTarget(Plr) then
        local Part = getPart()
        if Part then
            local Position = calculatePosition(Part, playerData[Plr].Velocity)
            mainEvent:FireServer(GetArgs(), Position)
        end
    end
end

client.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") then
        child.Activated:Connect(CharAdded)
    end
end)

client.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            child.Activated:Connect(CharAdded)
        end
    end)
end)

local function Process(player, dT)
    if not player or not player.Character then
        return
    end

    local PrimaryPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not PrimaryPart then
        return
    end

    if not playerData[player] then
        playerData[player] = {
            PreviousPosition = PrimaryPart.Position,
            Velocity = Vector3.new(0, 0, 0),
            OnScreen = false,
            ScreenPosition = Vector2.new(0, 0)
        }
    end

    local CurrentPosition = PrimaryPart.Position
    local PreviousPosition = playerData[player].PreviousPosition
    local Displacement = CurrentPosition - PreviousPosition

    local targetVelocity = Displacement / dT
    playerData[player].Velocity = playerData[player].Velocity:Lerp(targetVelocity, 0.5)
    playerData[player].PreviousPosition = CurrentPosition
    
    local ScreenPosition, OnScreen = workspace.CurrentCamera:WorldToViewportPoint(CurrentPosition)

    playerData[player].OnScreen = OnScreen
    playerData[player].ScreenPosition = Vector2.new(ScreenPosition.X, ScreenPosition.Y)
end

local strafeAngle = 0


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local Locking, Plr, strafing, walkspeedEnabled, auto_shooting, silentaimEnabled = false, nil, false, false, false, false
local playerData = {}
local savedPositions = {}
local posFileName = "elysian_button_positions.json"

-- === Utilities for saving positions ===
local function isfile_safe(name)
	local ok, res = pcall(function() return isfile(name) end)
	return ok and res
end
local function readfile_safe(name)
	local ok, res = pcall(function() return readfile(name) end)
	if ok then return res end
	return nil
end
local function writefile_safe(name, content)
	pcall(function() writefile(name, content) end)
end
local function SavePositions()
	pcall(function()
		writefile_safe(posFileName, HttpService:JSONEncode(savedPositions))
	end)
end
if isfile_safe(posFileName) then
	local raw = readfile_safe(posFileName)
	local ok, dec = pcall(function() return HttpService:JSONDecode(raw) end)
	if ok and type(dec) == "table" then savedPositions = dec end
end

-- === UI BUTTON CREATION ===
local ScreenGui = Instance.new("ScreenGui", CoreGui)
ScreenGui.Name = "Elysian_UI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local function CreateButton(name, defaultPosition, callback)
	local Button = Instance.new("TextButton")
	Button.Name = name
	Button.Size = UDim2.new(0, 110, 0, 44)
	Button.Position = savedPositions[name] and UDim2.new(0, savedPositions[name].X, 0, savedPositions[name].Y) or defaultPosition
	Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	Button.Text = name
	Button.TextColor3 = Color3.fromRGB(255, 255, 255)
	Button.Font = Enum.Font.Code
	Button.TextSize = 14
	Button.AutoButtonColor = false
	Button.Parent = ScreenGui

	local corner = Instance.new("UICorner", Button)
	corner.CornerRadius = UDim.new(0, 8)

	local Shadow = Instance.new("Frame", Button)
	Shadow.Size = UDim2.new(1, 6, 1, 6)
	Shadow.Position = UDim2.new(0, -3, 0, -3)
	Shadow.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
	Shadow.BackgroundTransparency = 0.7
	Shadow.ZIndex = 0
	local ShadowCorner = Instance.new("UICorner", Shadow)
	ShadowCorner.CornerRadius = UDim.new(0, 8)

	local isActive = false
	local function updateVisual()
		local targetColor = isActive and Color3.fromRGB(0, 200, 120) or Color3.fromRGB(180, 60, 60)
		TweenService:Create(Shadow, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			BackgroundColor3 = targetColor
		}):Play()
	end

	Button.MouseButton1Click:Connect(function()
		isActive = not isActive
		updateVisual()
		pcall(callback, isActive)
	end)

	-- Drag logic
	local dragStart, startPos
	Button.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragStart = input.Position
			startPos = Button.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragStart = nil
					startPos = nil
					savedPositions[name] = { X = Button.Position.X.Offset, Y = Button.Position.Y.Offset }
					SavePositions()
				end
			end)
		end
	end)
	Button.InputChanged:Connect(function(input)
		if dragStart and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
			local delta = input.Position - dragStart
			Button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)

	return Button
end

-- === TARGET STATS GUI ===
local StatsGui = Instance.new("ScreenGui", CoreGui)
StatsGui.Name = "Elysian_TargetStats"
local Frame = Instance.new("Frame", StatsGui)
Frame.AnchorPoint = Vector2.new(0.5, 1)
Frame.Position = UDim2.new(0.5, 0, 0.95, 0)
Frame.Size = UDim2.new(0, 300, 0, 60)
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Frame.BackgroundTransparency = 0.3
Frame.Visible = false
local Label = Instance.new("TextLabel", Frame)
Label.Size = UDim2.new(1, -12, 1, -12)
Label.Position = UDim2.new(0, 6, 0, 6)
Label.BackgroundTransparency = 1
Label.Font = Enum.Font.Code
Label.TextSize = 14
Label.TextColor3 = Color3.new(1, 1, 1)
Label.Text = ""

-- === TargetStats update loop ===
RunService.Heartbeat:Connect(function()
	if getgenv().Elysian['TargetStats'] and Plr and Plr.Character and Plr.Character:FindFirstChildOfClass("Humanoid") then
		local hum = Plr.Character:FindFirstChildOfClass("Humanoid")
		Frame.Visible = true
		Label.Text = string.format("🎯 Target: %s | ❤️ Health: %d/%d", Plr.Name, hum.Health, hum.MaxHealth)
	else
		Frame.Visible = false
	end
end)

local SilentAimBtn = CreateButton("Silent Aim", UDim2.new(0, 10, 0, 70), function(state)
	silentaimEnabled = state
end)


local function applyStats(humanoid)
    if not humanoid then return end

    if walkspeedEnabled then
        humanoid.WalkSpeed = getgenv().Elysian['HvH']['Walkspeed']['WalkSpeed']
        humanoid.JumpPower = getgenv().Elysian['HvH']['Walkspeed']['JumpPower']
    else
        humanoid.WalkSpeed = getgenv().Elysian['HvH']['Walkspeed']['DefaultWalkSpeed']
        humanoid.JumpPower = getgenv().Elysian['HvH']['Walkspeed']['DefaultJumpPower']
    end

    -- Protect against game resets
    humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if walkspeedEnabled then
            humanoid.WalkSpeed = getgenv().Elysian['HvH']['Walkspeed']['WalkSpeed']
        end
    end)
    humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if walkspeedEnabled then
            humanoid.JumpPower = getgenv().Elysian['HvH']['Walkspeed']['JumpPower']
        end
    end)
end

-- Apply stats when character is added
client.CharacterAdded:Connect(function(character)
    local humanoid = character:WaitForChild("Humanoid")
    applyStats(humanoid)
end)

-- Apply stats to current character if it exists
if client.Character then
    local humanoid = client.Character:FindFirstChild("Humanoid")
    if humanoid then
        applyStats(humanoid)
    end
end

local CamlockButton, getCamlockState = CreateButton("Camlock", UDim2.new(0, 10, 0, 10), function(state)
    Locking = state
    if Locking then
        Plr = GetClosestToCenter()
    else
        Plr = nil
        Background.Visible = false
    end
end)

if getgenv().Elysian['HvH']['Target Strafe']['Enabled'] then
    local StrafeButton, getStrafeState = CreateButton("Strafe", UDim2.new(0, 10, 0, 70), function(state)
        strafing = state
    end)
end

if getgenv().Elysian['HvH']['Walkspeed']['Enabled'] then
    local WalkspeedButton, getWalkspeedState = CreateButton("Walkspeed", UDim2.new(0, 10, 0, 130), function(state)
        walkspeedEnabled = state
        if client.Character then
            local humanoid = client.Character:FindFirstChild("Humanoid")
            if humanoid then
                applyStats(humanoid)
            end
        end
    end)
end

if getgenv().Elysian['Camlock']['Auto Air Shoot'] then
    local AutoShootButton, getAutoShootState = CreateButton("Auto Air Shoot", UDim2.new(0, 10, 0, 190), function(state)
        auto_shooting = state
    end)
end

userInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end -- Ignore input if processed by the game (e.g., typing in chat)

    -- Keybind for Q: Select Target (Camlock)
    if input.KeyCode == Enum.KeyCode.Q then
        Locking = not Locking
        if Locking then
            Plr = GetClosestToCenter()
        else
            Plr = nil
            Background.Visible = false
        end
        -- Update Camlock button state if it exists
        if CamlockButton then
            local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local targetColor = Locking and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            game:GetService("TweenService"):Create(CamlockButton:FindFirstChild("Shadow"), tweenInfo, {BackgroundColor3 = targetColor}):Play()
        end
    end

    -- Keybind for T: Toggle Walkspeed
    if input.KeyCode == Enum.KeyCode.T and getgenv().Elysian['HvH']['Walkspeed']['Enabled'] then
        walkspeedEnabled = not walkspeedEnabled
        if client.Character then
            local humanoid = client.Character:FindFirstChild("Humanoid")
            if humanoid then
                applyStats(humanoid)
            end
        end
        -- Update Walkspeed button state if it exists
        if WalkspeedButton then
            local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local targetColor = walkspeedEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            game:GetService("TweenService"):Create(WalkspeedButton:FindFirstChild("Shadow"), tweenInfo, {BackgroundColor3 = targetColor}):Play()
        end
    end

    -- Keybind for V: Toggle Strafe
    if input.KeyCode == Enum.KeyCode.Y and getgenv().Elysian['HvH']['Target Strafe']['Enabled'] then
        strafing = not strafing
        -- Update Strafe button state if it exists
        if StrafeButton then
            local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local targetColor = strafing and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            game:GetService("TweenService"):Create(StrafeButton:FindFirstChild("Shadow"), tweenInfo, {BackgroundColor3 = targetColor}):Play()
        end
    end

    -- Keybind for Z: Toggle Auto Air Shoot
    if input.KeyCode == Enum.KeyCode.Z and getgenv().Elysian['Camlock']['Auto Air Shoot'] then
        auto_shooting = not auto_shooting
        -- Update AutoShoot button state if it exists
        if AutoShootButton then
            local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local targetColor = auto_shooting and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            game:GetService("TweenService"):Create(AutoShootButton:FindFirstChild("Shadow"), tweenInfo, {BackgroundColor3 = targetColor}):Play()
        end
    end
end)

local function AutoShoot()
    if Locking and Plr and isValidTarget(Plr) then
        local humanoid = Plr.Character:FindFirstChild("Humanoid")
        if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            local character = client.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool and tool:IsA("Tool") then
                    tool:Activate()
                end
            end
        end
    end
end

runService.Heartbeat:Connect(function(dT)
    for _, player in ipairs(players:GetPlayers()) do
        if player ~= client then
            Process(player, dT)
        end
    end

    local rootPart = client.Character and client.Character:FindFirstChild("HumanoidRootPart")
    local old_position = rootPart and rootPart.CFrame or nil

    if getgenv().Elysian['HvH']['Target Strafe']['Enabled'] and strafing and Plr and Plr.Character and rootPart then
        local targetHRP = Plr.Character:FindFirstChild("HumanoidRootPart")
        local targetHead = Plr.Character:FindFirstChild("Head")
        if targetHRP and targetHead then
            strafeAngle = strafeAngle + math.rad(getgenv().Elysian['HvH']['Target Strafe']['Speed'])
            
            local distance = getgenv().Elysian['HvH']['Target Strafe']['Distance']
            local height = getgenv().Elysian['HvH']['Target Strafe']['Height']
            
            local offsetX = math.sin(strafeAngle) * distance
            local offsetZ = math.cos(strafeAngle) * distance
            local offsetY = math.sin(strafeAngle * 2) * height
            
            local predictedPosition = calculatePosition(targetHRP, playerData[Plr].Velocity)
            local strafePosition = predictedPosition + Vector3.new(offsetX, offsetY, offsetZ)
            
            -- Set fake position for HumanoidRootPart
            rootPart.CFrame = CFrame.new(strafePosition, predictedPosition)
            -- Set camera to target's Head
            workspace.CurrentCamera.CameraSubject = targetHead

            runService.RenderStepped:Wait()

            -- Update desync_setback to original position
            desync_setback.CFrame = old_position * CFrame.new(0, rootPart.Size.Y / 2 + 0.5, 0)
            -- Reset HumanoidRootPart to original position
            rootPart.CFrame = old_position
        end
    else
        -- Reset camera to player's humanoid if neither strafe nor desync is active
        if client.Character then
            local humanoid = client.Character:FindFirstChild("Humanoid")
            if humanoid then
                workspace.CurrentCamera.CameraSubject = humanoid
            end
        end
    end

    if auto_shooting and Plr and isValidTarget(Plr) then
        AutoShoot()
    end
end)

runService.RenderStepped:Connect(function()
    if Locking and Plr and Plr.Character and playerData[Plr] and isValidTarget(Plr) then
        local Part = getPart()
        if Part then
            local Position = calculatePosition(Part, playerData[Plr].Velocity)
            local Main = CFrame.new(camera.CFrame.p, Position)
            
            if getgenv().Elysian['Camlock']['Smoothing']['Enabled'] then
                camera.CFrame = camera.CFrame:Lerp(Main, getgenv().Elysian['Camlock']['Smoothing']['Value'])
            else
                camera.CFrame = Main
            end
        end
    end
end)

