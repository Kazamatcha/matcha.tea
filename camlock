-- Load the UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kazamatcha/matcha.tea/refs/heads/main/libpvp"))()
local flags = Library.Flags
getgenv().ConfigFolder = "matchafree"

-- Adjusted Window Size for better fit
local Window = Library:Window({Size = UDim2.new(0, 470, 0, 500)})

-- Services and Variables
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Global Settings
getgenv().Matcha = {
    Legit = {
        AimEnabled = false,
        Aimlock = false,
        SilentAim = false,
        Prediction = 0.135,
        Smoothing = false,
        SmoothingX = 0.5,
        SmoothingY = 0.5,
        Offset = false,
        JumpOffset = 0,
        HitPart = "Head",
		AutoSelect = false,
        Checks = {
            GrabbedKnocked = true
        },
		WallCheck = true,
        UseFOV = false,
        FOVSize = 150,
        FOVOutline = Color3.fromRGB(0, 0, 0),
        FOVInline = Color3.fromRGB(255, 255, 255),
        Chams = false,
        ChamsOutline = Color3.fromRGB(9, 0, 0),
        ChamsInline = Color3.fromRGB(255, 255, 255)
    },
    Character = {
        WalkSpeed = false,
        WalkSpeedValue = 50,
        WalkSpeedKey = "T",
        Fly = false,
        FlySpeed = 50,
        CFrameSpeed = false,
        CFrameSpeedValue = 50,
        AntiSlow = false,
		NoJumpCooldown = false,
    },
    Desync = {
	    Enabled = false,
	    Mode = "Void",
	    ToggleKeybind = false
    },
}

-- Storage
local Storage = {
    Targets = { Camlock = nil, Silent = nil },
    BodyParts = { Camlock = "", Silent = "" },
    CFPosition = nil,
    Connections = {},
    Drawings = { FOVCircle = nil },
    Targeting = false,
    LastNotifiedTarget = nil
}
local Waypoint = {
    Position = nil,
    Name = "Custom Waypoint"
}
local Lighting = game:GetService("Lighting")
local Original = {
	Ambient = Lighting.Ambient,
	FogColor = Lighting.FogColor,
	FogStart = Lighting.FogStart,
	FogEnd = Lighting.FogEnd,
	ClockTime = Lighting.ClockTime
}
getgenv().Matcha.BunnyHop = {
	Enabled = false,
	Speed = 50  -- T·ªëc ƒë·ªô nh·∫£y (t∆∞∆°ng ƒë∆∞∆°ng walkspeed)
}
-- Helper Functions
local function NewConnection(signal, callback)
    local conn = signal:Connect(callback)
    table.insert(Storage.Connections, conn)
    return conn
end
--=== [STORAGE CHO WORLD] ===--
getgenv().Matcha.World = {
    AmbientColor = Original.Ambient,
    FogColor = Original.FogColor,
    FogStart = Original.FogStart,
    FogEnd = Original.FogEnd
}
local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then return false end
    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then return false end
    end
    return true
end

-- Ki·ªÉm tra target c√≥ nh√¨n th·∫•y kh√¥ng
local function isVisible(targetPart)
    if not targetPart or not targetPart.Parent then return false end

    local origin = Camera.CFrame.Position
    local direction = targetPart.Position - origin -- g·ªçn h∆°n
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    params.IgnoreWater = true

    local ray = workspace:Raycast(origin, direction, params)
    if ray then
        -- N·∫øu tia ch·∫°m v·∫≠t kh√°c kh√¥ng ph·∫£i target th√¨ coi nh∆∞ b·ªã che
        return ray.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true -- kh√¥ng b·ªã che
end
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 2          -- line ch√≠nh
FOVCircle.Color = getgenv().Matcha.Legit.FOVOutline
FOVCircle.Transparency = 1
FOVCircle.Filled = false

local FOVOutline = Drawing.new("Circle")
FOVOutline.Thickness = 1         -- outline
FOVOutline.Color = getgenv().Matcha.Legit.FOVInline
FOVOutline.Transparency = 1
FOVOutline.Filled = false

local function getClosestPlayer(useFOV)
    local maxDist = useFOV and (getgenv().Matcha.Legit.FOVSize or 150) or math.huge
    local closest = nil

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local hum = plr.Character:FindFirstChildOfClass("Humanoid")
            if hum and hum.Health > 0 then
                local part = plr.Character:FindFirstChild(getgenv().Matcha.Legit.HitPart or "Head")
                if part then
                    -- Ch·ªâ check wall n·∫øu WallCheck b·∫≠t
                    if not getgenv().Matcha.Legit.WallCheck or isVisible(part) then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                        local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                        if dist < maxDist and onScreen then
                            closest = plr
                            maxDist = dist
                        end
                    end
                end
            end
        end
    end

    return closest
end

local function toggleTarget()
    Storage.Targeting = not Storage.Targeting
    if Storage.Targeting then
        local target = getClosestPlayer(getgenv().Matcha.Legit.UseFOV)
        if target then
            Storage.Targets.Camlock = target
            Storage.Targets.Silent = target
            Storage.BodyParts.Camlock = getgenv().Matcha.Legit.HitPart
            Storage.BodyParts.Silent = getgenv().Matcha.Legit.HitPart
            if target ~= Storage.LastNotifiedTarget then
                Library:Notification("Selected Target: " .. target.DisplayName .. " (@" .. target.Name .. ")", 3, Library.Accent, flags["Notification Position"])
                Storage.LastNotifiedTarget = target
            end
        else
            Storage.Targeting = false
        end
    else
        Storage.Targets.Camlock = nil
        Storage.Targets.Silent = nil
        Storage.LastNotifiedTarget = nil
    end
end
local function toggleTarget2()
    Storage.Targeting = not Storage.Targeting
    if Storage.Targeting then
        local target = getClosestPlayer(getgenv().Matcha.Legit.UseFOV)
        if target then
            Storage.Targets.Camlock = target
            Storage.Targets.Silent = target
            Storage.BodyParts.Camlock = getgenv().Matcha.Legit.HitPart
            Storage.BodyParts.Silent = getgenv().Matcha.Legit.HitPart
            if target ~= Storage.LastNotifiedTarget then
                Storage.LastNotifiedTarget = target
            end
        else
            Storage.Targeting = false
        end
    else
        Storage.Targets.Camlock = nil
        Storage.Targets.Silent = nil
        Storage.LastNotifiedTarget = nil
    end
end
local function updateCamlock()
    local target = Storage.Targets.Camlock
    if not getgenv().Matcha.Legit.Aimlock or not target or not target.Character then
        Storage.Targets.Camlock = nil
        return
    end

    local part = target.Character:FindFirstChild(getgenv().Matcha.Legit.HitPart or "Head")
    if not part or not isAlive(target) then
        return
    end

    -- Ch·ªâ check isVisible n·∫øu WallCheck b·∫≠t
    if getgenv().Matcha.Legit.WallCheck and not isVisible(part) then
        return
    end

    local pos = part.Position + (part.AssemblyLinearVelocity * (getgenv().Matcha.Legit.Prediction or 0))
    if getgenv().Matcha.Legit.Offset and target.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
        pos = pos + Vector3.new(0, getgenv().Matcha.Legit.JumpOffset or 0, 0)
    end

    local goal = CFrame.new(Camera.CFrame.Position, pos)
    if getgenv().Matcha.Legit.Smoothing then
        Camera.CFrame = Camera.CFrame:Lerp(goal, getgenv().Matcha.Legit.SmoothingX or 0.1, getgenv().Matcha.Legit.SmoothingY or 0.1)
    else
        Camera.CFrame = goal
    end
end


local function updateSilent()
    if getgenv().Matcha.Legit.SilentAim and Storage.Targets.Silent and Storage.Targets.Silent.Character then
        local part = Storage.Targets.Silent.Character:FindFirstChild(Storage.BodyParts.Silent)
        if part and isAlive(Storage.Targets.Silent) then
            local position = part.Position + (part.AssemblyLinearVelocity * getgenv().Matcha.Legit.Prediction)
            if getgenv().Matcha.Legit.Offset and Storage.Targets.Silent.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                position = position + Vector3.new(0, getgenv().Matcha.Legit.JumpOffset, 0)
            end
            Storage.CFPosition = position
        else
            Storage.Targets.Silent = nil
        end
    end
end

local noJumpCooldown = true
RunService.RenderStepped:Connect(function()
    if noJumpCooldown and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local hum = LocalPlayer.Character.Humanoid
        hum.UseJumpPower = not hum.UseJumpPower
    end
end)
local function applyChams(target)
    if not target or not target.Character then return end

    -- N·∫øu ƒë√£ c√≥ Highlight th√¨ update m√†u, kh√¥ng t·∫°o th√™m
    local highlight = target.Character:FindFirstChild("MatchaHighlight")
    if not highlight then
        highlight = Instance.new("Highlight")
        highlight.Name = "MatchaHighlight"
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.FillTransparency = 0.5
        highlight.Parent = target.Character
    end

    highlight.FillColor = getgenv().Matcha.Legit.ChamsInline or Color3.fromRGB(255, 255, 255)
    highlight.OutlineColor = getgenv().Matcha.Legit.ChamsOutline or Color3.fromRGB(255, 0, 0)
    highlight.Enabled = true
end

local function removeChams(target)
    if not target or not target.Character then return end
    local highlight = target.Character:FindFirstChild("MatchaHighlight")
    if highlight then
        highlight:Destroy()
    end
end

-- X√≥a chams kh·ªèi t·∫•t c·∫£ player tr·ª´ local
local function clearAllChams()
    for _, plr in ipairs(game:GetService("Players"):GetPlayers()) do
        if plr ~= game:GetService("Players").LocalPlayer and plr.Character then
            local hl = plr.Character:FindFirstChild("MatchaHighlight")
            if hl then hl:Destroy() end
        end
    end
end
--== [ NO JUMP COOLDOWN FIX ] ==--
RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        if getgenv().Matcha.Character.NoJumpCooldown then
            hum.UseJumpPower = false
        else
            hum.UseJumpPower = true
        end
    end
end)
getgenv().Matcha.ESP = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),
    NameEnabled = false,
    NameColor = Color3.fromRGB(255, 255, 255),
    NameMode = "DisplayName",
    NameSize = 14,
    DistanceEnabled = false,
    DistanceColor = Color3.fromRGB(255, 255, 255),
    DistanceSize = 14,
    HealthBar = false,
    HealthColor = Color3.fromRGB(0, 255, 0),
    WeaponEnabled = false,
    WeaponColor = Color3.fromRGB(255, 255, 255),
    ArmorBar = false,
    ArmorColor = Color3.fromRGB(0, 0, 255),
    Outline = false,
    PenisEnabled = false,
    PenisColor = Color3.fromRGB(255, 0, 0)
}

local ESPObjects = {}

-- Font (d√πng default c·ªßa Drawing: 2 = UI, nh∆∞ng script d√πng fontMap, gi·∫£ ƒë·ªãnh 2 cho SourceSans)
local font = 2 -- Enum.Font.Code ho·∫∑c t∆∞∆°ng t·ª±, nh∆∞ng Drawing d√πng number: 0=UI, 1=System, 2=Legacy, 3=Fantasy

-- Function to destroy ESP for a player
local function DestroyESP(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            obj:Remove()
        end
        ESPObjects[player] = nil
    end
end

-- Function to create ESP for a player
local function CreateESP(player)
    DestroyESP(player)

    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = getgenv().Matcha.ESP.Color
    box.Visible = false
    box.ZIndex = 1

    local boxOutline = Drawing.new("Square")
    boxOutline.Thickness = 3
    boxOutline.Filled = false
    boxOutline.Color = Color3.fromRGB(0, 0, 0)
    boxOutline.Visible = false
    boxOutline.ZIndex = 0

    local username = Drawing.new("Text")
    username.Size = getgenv().Matcha.ESP.NameSize
    username.Center = true
    username.Color = getgenv().Matcha.ESP.NameColor
    username.Visible = false
    username.Font = font
    username.Outline = getgenv().Matcha.ESP.Outline
    username.OutlineColor = Color3.fromRGB(0, 0, 0)

    local distance = Drawing.new("Text")
    distance.Size = getgenv().Matcha.ESP.DistanceSize
    distance.Center = true
    distance.Color = getgenv().Matcha.ESP.DistanceColor
    distance.Visible = false
    distance.Font = font
    distance.Outline = getgenv().Matcha.ESP.Outline
    distance.OutlineColor = Color3.fromRGB(0, 0, 0)

    local healthBar = Drawing.new("Square")
    healthBar.Thickness = 1
    healthBar.Filled = true
    healthBar.Color = getgenv().Matcha.ESP.HealthColor
    healthBar.Visible = false
    healthBar.ZIndex = 1

    local healthBarOutline = Drawing.new("Square")
    healthBarOutline.Thickness = 3
    healthBarOutline.Filled = false
    healthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    healthBarOutline.Visible = false
    healthBarOutline.ZIndex = 0

    local weapon = Drawing.new("Text")
    weapon.Size = getgenv().Matcha.ESP.NameSize
    weapon.Center = true
    weapon.Color = getgenv().Matcha.ESP.WeaponColor
    weapon.Visible = false
    weapon.Font = font
    weapon.Outline = getgenv().Matcha.ESP.Outline
    weapon.OutlineColor = Color3.fromRGB(0, 0, 0)

    local armorBar = Drawing.new("Square")
    armorBar.Thickness = 1
    armorBar.Filled = true
    armorBar.Color = getgenv().Matcha.ESP.ArmorColor
    armorBar.Visible = false
    armorBar.ZIndex = 1

    local armorBarOutline = Drawing.new("Square")
    armorBarOutline.Thickness = 3
    armorBarOutline.Filled = false
    armorBarOutline.Color = Color3.fromRGB(0, 0, 0)
    armorBarOutline.Visible = false
    armorBarOutline.ZIndex = 0

    local penisLine = Drawing.new("Line")
    penisLine.Thickness = 2
    penisLine.Color = getgenv().Matcha.ESP.PenisColor
    penisLine.Visible = false
    penisLine.ZIndex = 1

    ESPObjects[player] = {
        Box = box,
        BoxOutline = boxOutline,
        Username = username,
        Distance = distance,
        HealthBar = healthBar,
        HealthBarOutline = healthBarOutline,
        Weapon = weapon,
        ArmorBar = armorBar,
        ArmorBarOutline = armorBarOutline,
        PenisLine = penisLine
    }
end

-- Function to update ESP
local function UpdateESP()
    for player, objects in pairs(ESPObjects) do
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") and player ~= LocalPlayer and getgenv().Matcha.ESP.Enabled then
            local rootPart = character.HumanoidRootPart
            local humanoid = character:FindFirstChildOfClass("Humanoid")

            if humanoid and humanoid.Health > 0 then
                local rootPosition, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                local headPosition = Camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 3, 0))
                local footPosition = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0))

                if onScreen then
                    local boxHeight = math.abs(headPosition.Y - footPosition.Y)
                    local boxWidth = boxHeight / 2

                    -- Box ESP
                    objects.Box.Position = Vector2.new(rootPosition.X - boxWidth / 2, headPosition.Y)
                    objects.Box.Size = Vector2.new(boxWidth, boxHeight)
                    objects.Box.Color = getgenv().Matcha.ESP.Color
                    objects.Box.Visible = true

                    -- Box Outline
                    objects.BoxOutline.Position = Vector2.new(rootPosition.X - boxWidth / 2, headPosition.Y)
                    objects.BoxOutline.Size = Vector2.new(boxWidth, boxHeight)
                    objects.BoxOutline.Visible = getgenv().Matcha.ESP.Outline

                    -- Name ESP (Above the box)
                    if getgenv().Matcha.ESP.NameEnabled then
                        local displayName
                        if getgenv().Matcha.ESP.NameMode == "Username" then
                            displayName = player.Name
                        elseif getgenv().Matcha.ESP.NameMode == "DisplayName" then
                            displayName = player.DisplayName
                        elseif getgenv().Matcha.ESP.NameMode == "Username (DisplayName)" then
                            displayName = player.Name .. " (" .. player.DisplayName .. ")"
                        elseif getgenv().Matcha.ESP.NameMode == "Username (DisplayName) [UserID]" then
                            displayName = player.Name .. " (" .. player.DisplayName .. ") [" .. player.UserId .. "]"
                        end

                        objects.Username.Position = Vector2.new(rootPosition.X, headPosition.Y - 15)
                        objects.Username.Text = displayName
                        objects.Username.Size = getgenv().Matcha.ESP.NameSize
                        objects.Username.Visible = true
                        objects.Username.Color = getgenv().Matcha.ESP.NameColor
                        objects.Username.Outline = getgenv().Matcha.ESP.Outline
                    else
                        objects.Username.Visible = false
                    end

                    -- Distance ESP (Below the box)
                    if getgenv().Matcha.ESP.DistanceEnabled then
                        local distanceText = math.floor((LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude) .. " studs"
                        objects.Distance.Position = Vector2.new(rootPosition.X, footPosition.Y + 5)
                        objects.Distance.Text = distanceText
                        objects.Distance.Size = getgenv().Matcha.ESP.DistanceSize
                        objects.Distance.Visible = true
                        objects.Distance.Color = getgenv().Matcha.ESP.DistanceColor
                        objects.Distance.Outline = getgenv().Matcha.ESP.Outline
                    else
                        objects.Distance.Visible = false
                    end

                    -- Health Bar ESP
                    if getgenv().Matcha.ESP.HealthBar then
                        local healthRatio = humanoid.Health / humanoid.MaxHealth
                        local barHeight = boxHeight * healthRatio
                        objects.HealthBar.Position = Vector2.new(rootPosition.X - boxWidth / 2 - 6, headPosition.Y + (boxHeight - barHeight))
                        objects.HealthBar.Size = Vector2.new(3, barHeight)
                        objects.HealthBar.Color = getgenv().Matcha.ESP.HealthColor
                        objects.HealthBar.Visible = true

                        objects.HealthBarOutline.Position = Vector2.new(rootPosition.X - boxWidth / 2 - 6, headPosition.Y + (boxHeight - barHeight))
                        objects.HealthBarOutline.Size = Vector2.new(3, barHeight)
                        objects.HealthBarOutline.Visible = getgenv().Matcha.ESP.Outline
                    else
                        objects.HealthBar.Visible = false
                        objects.HealthBarOutline.Visible = false
                    end

                    -- Weapon ESP
                    if getgenv().Matcha.ESP.WeaponEnabled then
                        local tool = character:FindFirstChildOfClass("Tool")
                        if tool then
                            objects.Weapon.Position = Vector2.new(rootPosition.X, footPosition.Y + 20)
                            objects.Weapon.Text = tool.Name
                            objects.Weapon.Size = getgenv().Matcha.ESP.NameSize
                            objects.Weapon.Visible = true
                            objects.Weapon.Color = getgenv().Matcha.ESP.WeaponColor
                            objects.Weapon.Outline = getgenv().Matcha.ESP.Outline
                        else
                            objects.Weapon.Visible = false
                        end
                    else
                        objects.Weapon.Visible = false
                    end

                    -- Armor Bar ESP
                    if getgenv().Matcha.ESP.ArmorBar then
                        local dataFolder = player:FindFirstChild("DataFolder")
                        if dataFolder then
                            local information = dataFolder:FindFirstChild("Information")
                            if information then
                                local armorSave = information:FindFirstChild("ArmorSave")
                                if armorSave then
                                    local armorRatio = armorSave.Value / 130
                                    local armorHeight = boxHeight * armorRatio
                                    objects.ArmorBar.Position = Vector2.new(rootPosition.X + boxWidth / 2 + 3, headPosition.Y + (boxHeight - armorHeight))
                                    objects.ArmorBar.Size = Vector2.new(3, armorHeight)
                                    objects.ArmorBar.Color = getgenv().Matcha.ESP.ArmorColor
                                    objects.ArmorBar.Visible = true

                                    objects.ArmorBarOutline.Position = Vector2.new(rootPosition.X + boxWidth / 2 + 3, headPosition.Y + (boxHeight - armorHeight))
                                    objects.ArmorBarOutline.Size = Vector2.new(3, armorHeight)
                                    objects.ArmorBarOutline.Visible = getgenv().Matcha.ESP.Outline
                                else
                                    objects.ArmorBar.Visible = false
                                    objects.ArmorBarOutline.Visible = false
                                end
                            else
                                objects.ArmorBar.Visible = false
                                objects.ArmorBarOutline.Visible = false
                            end
                        else
                            objects.ArmorBar.Visible = false
                            objects.ArmorBarOutline.Visible = false
                        end
                    else
                        objects.ArmorBar.Visible = false
                        objects.ArmorBarOutline.Visible = false
                    end

                    -- Penis ESP
                    if getgenv().Matcha.ESP.PenisEnabled then
                        local pelvis = character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso")
                        if pelvis then
                            local pelvisPosition = Camera:WorldToViewportPoint(pelvis.Position)
                            local lookVector = rootPart.CFrame.LookVector
                            local penisEndPosition = Camera:WorldToViewportPoint(pelvis.Position + lookVector * 2)

                            objects.PenisLine.From = Vector2.new(pelvisPosition.X, pelvisPosition.Y)
                            objects.PenisLine.To = Vector2.new(penisEndPosition.X, penisEndPosition.Y)
                            objects.PenisLine.Color = getgenv().Matcha.ESP.PenisColor
                            objects.PenisLine.Visible = true
                        else
                            objects.PenisLine.Visible = false
                        end
                    else
                        objects.PenisLine.Visible = false
                    end
                else
                    for _, obj in pairs(objects) do
                        obj.Visible = false
                    end
                end
            end
        end
    end
end

-- Player Added/Removed Events
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait(1)
        CreateESP(player)
    end)
end)

Players.PlayerRemoving:Connect(DestroyESP)

-- Initialize ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESP(player)
    end
end

-- Update ESP on every frame
NewConnection(RunService.RenderStepped, UpdateESP)
RunService.RenderStepped:Connect(function()
	if getgenv().Matcha.BunnyHop.Enabled and LocalPlayer.Character then
	    local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	    
	    if hum and hrp and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
	        hum.Jump = true
	        
	        local dir = Camera.CFrame.LookVector * Vector3.new(1, 0, 1)
	        local move = Vector3.zero
	        
	        if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += dir end
	        if UserInputService:IsKeyDown(Enum.KeyCode.S) then move -= dir end
	        if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += Vector3.new(-dir.Z, 0, dir.X) end
	        if UserInputService:IsKeyDown(Enum.KeyCode.A) then move += Vector3.new(dir.Z, 0, -dir.X) end
	        
	        if move.Magnitude > 0 then
	            local speed = getgenv().Matcha.BunnyHop.Speed
	            hrp.Velocity = Vector3.new(move.Unit.X * speed, hrp.Velocity.Y, move.Unit.Z * speed)
	        end
	    end
	end
    if getgenv().Matcha.Legit.UseFOV then
        local pos = UserInputService:GetMouseLocation()
        FOVCircle.Radius = getgenv().Matcha.Legit.FOVSize
        FOVCircle.Position = pos
        FOVCircle.Color = getgenv().Matcha.Legit.FOVOutline
        FOVCircle.Visible = true

        FOVOutline.Radius = getgenv().Matcha.Legit.FOVSize
        FOVOutline.Position = pos
        FOVOutline.Color = getgenv().Matcha.Legit.FOVInline
        FOVOutline.Visible = true
    else
        FOVCircle.Visible = false
        FOVOutline.Visible = false
    end

    --=== [AUTO SELECT] ===--
    if getgenv().Matcha.Legit.AutoSelect then
        toggleTarget2()
    end

    --=== [CHAMS] ===--
    local currentTarget = Storage.Targets.Camlock
    if getgenv().Matcha.Legit.Chams and currentTarget and currentTarget.Character then
        applyChams(currentTarget)
    else
        clearAllChams()
    end
end)

-- Anti Slow Logic
local function toggleAntiSlow(bool)
    if bool then
        RunService:BindToRenderStep("Anti-Slow", 0, function()
            if LocalPlayer.Character.BodyEffects.Movement:FindFirstChild("NoWalkSpeed") then LocalPlayer.Character.BodyEffects.Movement.NoWalkSpeed:Destroy() end
            if LocalPlayer.Character.BodyEffects.Movement:FindFirstChild("ReduceWalk") then LocalPlayer.Character.BodyEffects.Movement.ReduceWalk:Destroy() end
            if LocalPlayer.Character.BodyEffects.Movement:FindFirstChild("NoJumping") then LocalPlayer.Character.BodyEffects.Movement.NoJumping:Destroy() end
            if LocalPlayer.Character.BodyEffects.Reload.Value then LocalPlayer.Character.BodyEffects.Reload.Value = false end
        end)
    else
        RunService:UnbindFromRenderStep("Anti-Slow")
    end
end

-- WalkSpeed
NewConnection(RunService.RenderStepped, function()
    if getgenv().Matcha.Character.WalkSpeed and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.WalkSpeed = getgenv().Matcha.Character.WalkSpeedValue
    end
end)

-- Fly (Simple Implementation)
local flyConnections = {}
local function toggleFly(enabled)
    if enabled then
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.Parent = LocalPlayer.Character.HumanoidRootPart
        bodyVelocity.MaxForce = Vector3.new(1e9, 1e9, 1e9)
        bodyVelocity.Velocity = Vector3.zero

        flyConnections[1] = RunService.RenderStepped:Connect(function()
            local moveDirection = Vector3.zero
            local flySpeed = getgenv().Matcha.Character.FlySpeed or 100

            -- Forward / Backward
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + Camera.CFrame.LookVector
            elseif UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - Camera.CFrame.LookVector
            end

            -- Left / Right
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - Camera.CFrame.RightVector
            elseif UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + Camera.CFrame.RightVector
            end

            -- Up / Down
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDirection = moveDirection + Vector3.new(0, 1, 0)
            elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDirection = moveDirection - Vector3.new(0, 1, 0)
            end

            if moveDirection.Magnitude > 0 then
                bodyVelocity.Velocity = moveDirection.Unit * flySpeed
            else
                bodyVelocity.Velocity = Vector3.zero
            end
        end)
    else
        for _, conn in pairs(flyConnections) do
            conn:Disconnect()
        end
        table.clear(flyConnections)
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp and hrp:FindFirstChild("BodyVelocity") then
            hrp.BodyVelocity:Destroy()
        end
    end
end
local RunService = game:GetService("RunService")
local LocalPlayer = game.Players.LocalPlayer

RunService.RenderStepped:Connect(function(dt)
    local char = LocalPlayer.Character
    if not char then return end

    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")

    -- Ki·ªÉm tra n·∫øu b·∫≠t CFrameSpeed
    if hum and hrp and getgenv().Matcha.Character.CFrameSpeed then
        local moveDir = hum.MoveDirection
        if moveDir.Magnitude > 0 then
            -- T·ªëc ƒë·ªô = MoveDir * dt * speed * multiplier
            hrp.CFrame = hrp.CFrame + (moveDir * dt) * (getgenv().Matcha.Character.CFrameSpeedValue or 20) * 10
        end
    end
end)

-- Main Connections
NewConnection(RunService.Heartbeat, function()
    if getgenv().Matcha.Legit.AimEnabled then
        updateCamlock()
        updateSilent()
    end
end)

-- Silent Aim Hook (Assuming hookmetamethod support)
pcall(function()
    local oldIndex = hookmetamethod(game, "__index", function(self, key)
        if not checkcaller() and getgenv().Matcha.Legit.SilentAim and Storage.CFPosition then
            if self == Mouse and (key == "Hit" or key == "Target") then
                local spoof = CFrame.new(Storage.CFPosition)
                if key == "Hit" then return spoof end
                if key == "Target" then
                    local part = Instance.new("Part")
                    part.CFrame = spoof
                    part.Transparency = 1
                    part.Anchored = true
                    part.CanCollide = false
                    part.Parent = workspace
                    delay(0.1, function() part:Destroy() end)
                    return part
                end
            end
        end
        return oldIndex(self, key)
    end)
end)
local desync_setback = Instance.new("Part")
desync_setback.Name = "DesyncSetback"
desync_setback.Size = Vector3.new(2, 2, 1)
desync_setback.CanCollide = false
desync_setback.Anchored = true
desync_setback.Transparency = 1
desync_setback.Parent = workspace

-- Anti Lock Storage
getgenv().Matcha.AntiLock = {
    Enabled = false,
    Mode = "Custom",
    Custom = { X = 0, Y = 0, Z = 0 },
    Up = { Amount = 0 },
    Down = { Amount = 0 },
    VelMultiply = { Walk = 0, Jump = 0 },
    LookVec = { Amount = 0 },
    Reverse = { Amount = 0, Type = "CFrame" },
    Confusion = { Amount = 0 },
    PredBreaker = false
}

-- Helper: Reset Camera
local function resetCamera()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
    end
end

-- Toggle Desync
local function toggleDesync()
    if getgenv().Matcha.Desync.Enabled then
        workspace.CurrentCamera.CameraSubject = desync_setback
        Library:Notification("Desync: ON [" .. getgenv().Matcha.Desync.Mode .. "]", 2)
    else
        resetCamera()
        Library:Notification("Desync: OFF", 2)
    end
end
NewConnection(RunService.Heartbeat, function()
    local target = Storage.Targets.Camlock or Storage.Targets.Silent
    if not target or not target.Character then return end

    local part = target.Character:FindFirstChild(getgenv().Matcha.Legit.HitPart or "Head")
    if not part or not isAlive(target) then return end

    if getgenv().Matcha.Legit.WallCheck and not isVisible(part) then return end

    local predicted = part.Position + (part.AssemblyLinearVelocity * (getgenv().Matcha.Legit.Prediction or 0.135))
    if getgenv().Matcha.Legit.Offset and target.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
        predicted = predicted + Vector3.new(0, getgenv().Matcha.Legit.JumpOffset or 0, 0)
    end

    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- [VIEW TARGET] - Ch·ªâ camera nh√¨n + ƒë·ªïi CameraSubject
    if getgenv().Matcha.Legit.ViewTarget then
        Camera.CFrame = CFrame.new(Camera.CFrame.Position, predicted)
        workspace.CurrentCamera.CameraSubject = target.Character.Humanoid
    end

    -- [LOOK AT] - Xoay nh√¢n v·∫≠t
    if getgenv().Matcha.Legit.LookAt then
        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.lookAt(hrp.Position, predicted))
    end
end)
-- Desync Heartbeat
NewConnection(RunService.Heartbeat, function()
    if not getgenv().Matcha.Desync.Enabled or not LocalPlayer.Character then return end
    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local old = hrp.CFrame
    local pos = old.Position

    if getgenv().Matcha.Desync.Mode == "Destroy Cheaters" then
        pos = Vector3.new(9e9, 1, 1)
    elseif getgenv().Matcha.Desync.Mode == "Underground" then
        pos = pos - Vector3.new(0, 12, 0)
    elseif getgenv().Matcha.Desync.Mode == "Void Spam" then
        pos = math.random(1,2) == 1 and old.Position or Vector3.new(math.random(10000,50000), math.random(10000,50000), math.random(10000,50000))
    elseif getgenv().Matcha.Desync.Mode == "Void" then
        pos = pos + Vector3.new(math.random(-444444,444444), math.random(-444444,444444), math.random(-44444,44444))
    end

    hrp.CFrame = CFrame.new(pos)
    workspace.CurrentCamera.CameraSubject = desync_setback
    RunService.RenderStepped:Wait()
    desync_setback.CFrame = old * CFrame.new(0, hrp.Size.Y/2 + 0.5, 0)
    hrp.CFrame = old
end)

-- Anti Lock Heartbeat
NewConnection(RunService.Heartbeat, function()
    if not getgenv().Matcha.AntiLock.Enabled or not LocalPlayer.Character then return end
    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not hrp or not hum then return end

    local vel = hrp.Velocity
    local cf = hrp.CFrame

    local S = getgenv().Matcha.AntiLock

    if S.Mode == "Custom" and S.Custom.X ~= 0 or S.Custom.Y ~= 0 or S.Custom.Z ~= 0 then
        hrp.Velocity = Vector3.new(S.Custom.X, S.Custom.Y, S.Custom.Z)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "Up" and S.Up.Amount > 0 then
        hrp.Velocity = Vector3.new(vel.X, S.Up.Amount, vel.Z)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "Down" and S.Down.Amount > 0 then
        hrp.Velocity = Vector3.new(vel.X, -S.Down.Amount, vel.Z)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "VelMultiply" and (S.VelMultiply.Walk > 0 or S.VelMultiply.Jump > 0) then
        hrp.Velocity = vel * Vector3.new(S.VelMultiply.Walk, S.VelMultiply.Jump, S.VelMultiply.Walk)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "LookVec" and S.LookVec.Amount > 0 then
        hrp.Velocity = cf.lookVector * S.LookVec.Amount
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "Reverse" and S.Reverse.Amount > 0 then
        if S.Reverse.Type == "CFrame" then
            hrp.CFrame = cf - hum.MoveDirection * (S.Reverse.Amount / 10)
        else
            hrp.Velocity = vel * Vector3.new(-S.Reverse.Amount/2.5, 1, -S.Reverse.Amount/2.5)
            RunService.RenderStepped:Wait()
            hrp.Velocity = vel
        end
    elseif S.Mode == "Confusion" and S.Confusion.Amount > 0 then
        hrp.CFrame = cf * CFrame.new(math.random(1,2)==1 and S.Confusion.Amount or -S.Confusion.Amount, 0, 0)
    elseif S.Mode == "PredBreaker" then
        hrp.Velocity = Vector3.zero
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    end
end)
-- UI Pages
local LegitPage = Window:Page({Name = "Legit"}) do
    local AimSection = LegitPage:Section({Name = "Aim Assist", Size = 400})
	local AimSection2 = LegitPage:Section({Name = "Aim setting", Size = 400, Side = "Right"})
    AimSection:Toggle({Name = "Aim Enabled", Flag = "AimEnabled", Callback = function(bool) getgenv().Matcha.Legit.AimEnabled = bool end}):Keybind({Name = "Select Target", Flag = "SelectTargetBind", Mode = "Toggle", Callback = toggleTarget})
    AimSection:Toggle({Name = "Aimlock", Flag = "Aimlock", Callback = function(bool) getgenv().Matcha.Legit.Aimlock = bool end})
	AimSection:Toggle({
		Name = "Auto Select",
		Flag = "AutoSelect",
		Default = false,
		Callback = function(bool)
			getgenv().Matcha.Legit.AutoSelect = bool
		end
	})
    AimSection:Toggle({
		Name = "Silent Aim",
		Flag = "SilentAim",
		Callback = function(bool)
			getgenv().Matcha.Legit.SilentAim = bool

			-- N·∫øu b·∫≠t m√† executor KH√îNG h·ªó tr·ª£ hookmetamethod ‚Üí c·∫£nh b√°o
			if bool and not hookmetamethod then
				getgenv().Matcha.Legit.SilentAim = false  -- t·ª± ƒë·ªông t·∫Øt
				Library:Notification("Warning: Your executor does not support Silent Aim (hookmetamethod missing).", 5, Color3.fromRGB(255, 200, 0))
			end
		end
	})
    AimSection:Textbox({Name = "Prediction", Flag = "Prediction", Placeholder = "0.135", Callback = function(val) getgenv().Matcha.Legit.Prediction = tonumber(val) end})
    AimSection:Toggle({Name = "Smoothing", Flag = "Smoothing", Callback = function(bool) getgenv().Matcha.Legit.Smoothing = bool end})
    AimSection:Textbox({Name = "Smoothing X", Flag = "SmoothingX", Placeholder = "0.5", Callback = function(val) getgenv().Matcha.Legit.SmoothingX = tonumber(val) end})
    AimSection:Textbox({Name = "Smoothing Y", Flag = "SmoothingY", Placeholder = "0.5", Callback = function(val) getgenv().Matcha.Legit.SmoothingY = tonumber(val) end})
    AimSection:Toggle({Name = "Jump Offset", Flag = "Offset", Callback = function(bool) getgenv().Matcha.Legit.Offset = bool end})
    AimSection:Textbox({Name = "Jump Offset Value", Flag = "JumpOffset", Placeholder = "0", Callback = function(val) getgenv().Matcha.Legit.JumpOffset = tonumber(val) end})
    AimSection:Dropdown({Name = "Hit Part", Flag = "HitPart", Options = {"Head", "HumanoidRootPart", "UpperTorso", "Torso(R6)", "LowerTorso"}, Default = "HumanoidRootPart", Callback = function(opt) getgenv().Matcha.Legit.HitPart = opt end})
    AimSection2:Toggle({Name = "Alive Check", Flag = "Alive Check", Callback = function(bool) getgenv().Matcha.Legit.Checks.GrabbedKnocked = bool end})
	AimSection2:Toggle({
		Name = "Wall Check",
		Flag = "WallCheck",
		Default = true,
		Callback = function(bool)
			getgenv().Matcha.Legit.WallCheck = bool
		end
	})

	-- LEGIT VISUALS SETTINGS
	AimSection2:Toggle({
		Name = "Use FOV",
		Flag = "UseFOV",
		Default = false,
		Callback = function(bool)
			getgenv().Matcha.Legit.UseFOV = bool
		end
	})

	AimSection2:Slider({
		Name = "FOV Size",
		Flag = "FOVSize",
		Min = 1,
		Max = 1000,
		Default = 150,
		Callback = function(val)
			getgenv().Matcha.Legit.FOVSize = val
		end
	})

	AimSection2:Colorpicker({
		Name = "FOV Outline",
		Flag = "FOVOutline",
		Default = Color3.fromRGB(0, 0, 0),
		Callback = function(col)
			getgenv().Matcha.Legit.FOVOutline = col
		end
	})

	AimSection2:Colorpicker({
		Name = "FOV Inline",
		Flag = "FOVInline",
		Default = Color3.fromRGB(255, 255, 255),
		Callback = function(col)
			getgenv().Matcha.Legit.FOVInline = col
		end
	})

	--== CHAMS SETTINGS ==--
	AimSection2:Toggle({
		Name = "Chams Target",
		Flag = "Chams",
		Default = false,
		Callback = function(bool)
			getgenv().Matcha.Legit.Chams = bool
		end
	})

	AimSection2:Colorpicker({
		Name = "Chams Outline",
		Flag = "ChamsOutline",
		Default = Color3.fromRGB(255, 0, 0),
		Callback = function(col)
			getgenv().Matcha.Legit.ChamsOutline = col
		end
	})

	AimSection2:Colorpicker({
		Name = "Chams Inline",
		Flag = "ChamsInline",
		Default = Color3.fromRGB(255, 255, 255),
		Callback = function(col)
			getgenv().Matcha.Legit.ChamsInline = col
		end
	})

	local MiscSection = LegitPage:Section({Name = "Misc", Size = 50, Side = "Right"})
	
	-- // C·∫§U H√åNH RAPID FIRE
	getgenv().Matcha.RapidFire = {
	    Enabled = false,
	    Delay = 0,          
	    IsFiring = false
	}
	
	-- // UTILITY: L·∫§Y S√öNG TRONG NH√ÇN V·∫¨T
	local function getGun()
	    local char = LocalPlayer.Character
	    if not char then return end
	    for _, tool in ipairs(char:GetChildren()) do
	        if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
	            return tool
	        end
	    end
	end
	
	-- // INPUT SERVICE
	local UIS = game:GetService("UserInputService")
	
	-- // B·∫ÆT ƒê·∫¶U B·∫ÆN
	UIS.InputBegan:Connect(function(input, gameProcessed)
	    if gameProcessed or input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
	
	    local gun = getGun()
	    if not getgenv().Matcha.RapidFire.Enabled or not gun or getgenv().Matcha.RapidFire.IsFiring then return end
	
	    getgenv().Matcha.RapidFire.IsFiring = true
	
	    task.spawn(function()
	        while getgenv().Matcha.RapidFire.IsFiring and getgenv().Matcha.RapidFire.Enabled do
	            pcall(function()
	                gun:Activate()  -- G·ªçi Activate() ‚Üí game s·∫Ω t·ª± x·ª≠ l√Ω b·∫Øn
	            end)
	            task.wait(getgenv().Matcha.RapidFire.Delay)
	        end
	    end)
	end)
	
	-- // D·ª™NG B·∫ÆN
	UIS.InputEnded:Connect(function(input)
	    if input.UserInputType == Enum.UserInputType.MouseButton1 then
	        getgenv().Matcha.RapidFire.IsFiring = false
	    end
	end)
	
	-- // UI: TOGGLE + SLIDER
	MiscSection:Toggle({
	    Name = "Rapid Fire",
	    Flag = "RapidFire",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.RapidFire.Enabled = bool
	        if bool then
	            Library:Notification("Rapid Fire: ON", 2, Color3.fromRGB(0,255,0))
	        else
	            getgenv().Matcha.RapidFire.IsFiring = false
	            Library:Notification("Rapid Fire: OFF", 2, Color3.fromRGB(255,0,0))
	        end
	    end
	})

end

local CharacterPage = Window:Page({Name = "Character", Weapons = true}) do
    local Movement = CharacterPage:Weapon({Icon = "rbxassetid://6034509993"})
    local Avatars = CharacterPage:Weapon({Icon = "rbxassetid://16997954488"})
    local AntiAim = CharacterPage:Weapon({Icon = "rbxassetid://16997762295"})
    local Esp = CharacterPage:Weapon({Icon = "http://www.roblox.com/asset/?id=77746565540051"})

    local MovementSection = Movement:Section({Name = "Movement", Size = 300})
    MovementSection:Toggle({Name = "WalkSpeed", Flag = "WalkSpeed", Callback = function(bool) getgenv().Matcha.Character.WalkSpeed = bool end}):Keybind({Name = "WalkSpeed Key", Flag = "WalkSpeedKey", Mode = "Toggle", Callback = function(bool) getgenv().Matcha.Character.WalkSpeed = bool end})
    MovementSection:Slider({Name = "WalkSpeed Value", Flag = "WalkSpeedValue", Min = 16, Max = 300, Default = 50, Callback = function(val) getgenv().Matcha.Character.WalkSpeedValue = val end})
    MovementSection:Toggle({Name = "Fly", Flag = "Fly", Callback = function(bool) getgenv().Matcha.Character.Fly = bool; toggleFly(bool) end}):Keybind({Name = "Fly Key", Flag = "Flykey", Mode = "Toggle", Callback = function(bool) getgenv().Matcha.Character.Fly = bool; toggleFly(bool) end})
    MovementSection:Slider({Name = "Fly Speed", Flag = "FlySpeed", Min = 10, Max = 500, Default = 50, Callback = function(val) getgenv().Matcha.Character.FlySpeed = val end})
    MovementSection:Toggle({Name = "CFrame Speed", Flag = "CFrameSpeed", Callback = function(bool) getgenv().Matcha.Character.CFrameSpeed = bool end}):Keybind({Name = "CframeSpeed Key", Flag = "CframeSpeedKey", Mode = "Toggle", Callback = function(bool) getgenv().Matcha.Character.CFrameSpeed = bool end})
    MovementSection:Slider({Name = "CFrame Speed Value", Flag = "CFrameSpeedValue", Min = 10, Max = 500, Default = 50, Callback = function(val) getgenv().Matcha.Character.CFrameSpeedValue = val end})
	-- // C·∫§U H√åNH BUNNYHOP
	
	MovementSection:Toggle({
	    Name = "üêá Bunny Hop", 
	    Flag = "BunnyHop",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.BunnyHop.Enabled = bool
	        if bool then
	            Library:Notification("Bunny Hop: ON", 2, Color3.fromRGB(0,255,0))
	        else
	            Library:Notification("Bunny Hop: OFF", 2, Color3.fromRGB(255,0,0))
	        end
	    end
	}):Keybind({
	    Name = "Bunny Key",
	    Flag = "BunnyKeybind",
	    Mode = "Toggle",
	    Callback = function(bool)
	        getgenv().Matcha.BunnyHop.Enabled = bool
	    end
	})
	
	MovementSection:Slider({
	    Name = "Bunny Speed",
	    Flag = "BunnySpeed",
	    Min = 16,
	    Max = 300,
	    Default = 50,
	    Callback = function(val)
	        getgenv().Matcha.BunnyHop.Speed = val
	    end
	})
    MovementSection:Toggle({Name = "Anti Slowdown", Flag = "AntiSlow", Callback = function(bool) getgenv().Matcha.Character.AntiSlow = bool; toggleAntiSlow(bool) end})
	MovementSection:Toggle({Name = "No Jump Cooldown", Flag = "No Jump Cooldown", Callback = function(bool) getgenv().Matcha.Character.NoJumpCooldown = bool end})
    MovementSection:Button({
	    Name = "TP to Target",
	    Callback = function()
	        local target = Storage.Targets.Camlock or Storage.Targets.Silent
	        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
	            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	            if root then
	                root.CFrame = target.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
	            end
	        else
	            Library:Notification("No target selected!", 2)
	        end
	    end
	})
    local TeleportSection = Movement:Section({Name = "Teleports", Size = 300, Side = "Right"})
    TeleportSection:Button({Name = "Admin Base", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-797.15, -39.6189, -887.957) end})
    TeleportSection:Button({Name = "Food Shop [Bank]", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-335.141, 23.7129, -298.029) end})
    TeleportSection:Button({Name = "Food Shop [Uphill]", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(298.477, 49.3129, -615.231) end})
    TeleportSection:Button({Name = "Food Shop [Taco]", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(583.96, 51.0917, -479.596) end})
    TeleportSection:Button({Name = "Food Shop [Hamburger]", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-279.501, 22.6801, -803.887) end})
    TeleportSection:Button({Name = "Gun Shop [Uphill]", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(481.925, 48.1008, -621.23) end})
    TeleportSection:Button({Name = "Gun Shop [Armor]", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-580.27, 8.34504, -734.832) end})
    TeleportSection:Button({Name = "Bank", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-438.689, 39.0127, -284.731) end})
    TeleportSection:Button({Name = "Police Station", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-263.919, 21.8302, -112.858) end})
    TeleportSection:Button({Name = "Fire Department", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-129.534, 27.842, -113.062) end})
    TeleportSection:Button({Name = "Church", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(205.53, 21.7803, -80.2361) end})
    TeleportSection:Button({Name = "Casino", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-904.457, 24.7803, -156.994) end})
    TeleportSection:Button({Name = "School", Callback = function() LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-578, 22, 337) end})
	TeleportSection:Button({
	    Name = "Save Waypoint",
	    Callback = function()
	        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	        if hrp then
	            Waypoint.Position = hrp.Position
	            Library:Notification("Waypoint saved!", 2, Color3.fromRGB(0,255,0))
	        else
	            Library:Notification("No character!", 2, Color3.fromRGB(255,0,0))
	        end
	    end
	})
	
	TeleportSection:Button({
	    Name = "Go to Waypoint",
	    Callback = function()
	        if Waypoint.Position then
	            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	            if hrp then
	                hrp.CFrame = CFrame.new(Waypoint.Position)
	                Library:Notification("Teleported to waypoint!", 2, Color3.fromRGB(0,255,0))
	            end
	        else
	            Library:Notification("No waypoint saved!", 2, Color3.fromRGB(255,0,0))
	        end
	    end
	})

	-- Thay th·∫ø ho√†n to√†n ph·∫ßn c≈© trong CharacterPage (Avatars + AnimationSection)
	
	-- Th√™m v√†o CharacterPage, thay th·∫ø ph·∫ßn c≈©
	local AvatarSection = Avatars:Section({Name = "Avatar Changer", Size = 300})
	local AnimationSection = Avatars:Section({Name = "Animations", Size = 300, Side = "Right"})
	
	-- // ==================== [S·ª¨A AVATAR + ANIMATION - TOGGLE + AUTO RESTORE] ==================== //
	
	-- [=== GLOBAL STORAGE ===]
	getgenv().Matcha.Avatar = {
	    Headless = false,
	    Korblox = false,
	    Face = {
	        Blizzard = false,
	        SuperHappy = false,
	        Beast = false,
	        Vampire = false
	    }
	}
	
	getgenv().Matcha.Animations = {
	    ZombieTOM = false,
	    ZombieTM = false,
	    ZombieRunWalk = false
	}
	
	-- [=== HELPER: SAFE GET CHARACTER ===]
	local function getChar()
	    local char = LocalPlayer.Character
	    if char then return char end
	    LocalPlayer.CharacterAdded:Wait()
	    return LocalPlayer.Character
	end
	
	-- [=== HEADLESS TOGGLE ===]
	local function applyHeadless(state)
	    local char = getChar()
	    local head = char:FindFirstChild("Head")
	    if head then
	        head.Transparency = state and 1 or 0
	        local face = head:FindFirstChild("face")
	        if face then face.Transparency = state and 1 or 0 end
	    end
	end
	
	-- [=== KORBLOX TOGGLE ===]
	local korbloxWeld = nil
	local function applyKorblox(state)
	    local char = getChar()
	    local rightUpperLeg = char:FindFirstChild("RightUpperLeg")
	    if not rightUpperLeg then return end
	    
	    if state then
	        -- ·∫®n ch√¢n
	        local rightLowerLeg = char:FindFirstChild("RightLowerLeg")
	        local rightFoot = char:FindFirstChild("RightFoot")
	        if rightLowerLeg then rightLowerLeg.Transparency = 1 end
	        if rightFoot then rightFoot.Transparency = 1 end
	        
	        -- T·∫°o Korblox
	        local accessory = Instance.new("Accessory")
	        accessory.Name = "KorbloxLeg"
	        local handle = Instance.new("Part")
	        handle.Name = "Handle"
	        handle.Size = Vector3.new(1, 2, 1)
	        handle.Transparency = 1
	        handle.CanCollide = false
	        handle.Parent = accessory
	        
	        local mesh = Instance.new("SpecialMesh")
	        mesh.MeshId = "rbxassetid://902942096"
	        mesh.TextureId = "rbxassetid://902843398"
	        mesh.Scale = Vector3.new(1.1, 1.1, 1.1)
	        mesh.Parent = handle
	        
	        accessory.Parent = char
	        
	        -- Weld
	        korbloxWeld = Instance.new("Weld")
	        korbloxWeld.Part0 = handle
	        korbloxWeld.Part1 = rightUpperLeg
	        korbloxWeld.C0 = CFrame.new(0, -0.12, 0)
	        korbloxWeld.Parent = handle
	    else
	        -- X√≥a Korblox
	        local acc = char:FindFirstChild("KorbloxLeg")
	        if acc then acc:Destroy() end
	        korbloxWeld = nil
	        
	        -- Hi·ªán ch√¢n
	        local rightLowerLeg = char:FindFirstChild("RightLowerLeg")
	        local rightFoot = char:FindFirstChild("RightFoot")
	        if rightLowerLeg then rightLowerLeg.Transparency = 0 end
	        if rightFoot then rightFoot.Transparency = 0 end
	    end
	end
	
	-- [=== FACE SYSTEM ===]
	local function setFace(faceName, state)
	    local char = getChar()
	    local head = char:FindFirstChild("Head")
	    if not head or not head:FindFirstChild("face") then return end
	    
	    local faceMap = {
	        Blizzard = "209712379",
	        SuperHappy = "494290547", 
	        Beast = "127959433",
	        Vampire = "2409281591"
	    }
	    
	    if state and faceMap[faceName] then
	        head.face.Texture = "rbxassetid://" .. faceMap[faceName]
	    elseif not state then
	        head.face.Texture = "rbxassetid://231508486" -- Default Roblox face
	    end
	end
	
	-- [=== ANIMATION APPLY ===]
	local function applyAnimationPack(packName)
	    local char = getChar()
	    if not char or not char:FindFirstChild("Animate") then return end
	    local animate = char.Animate
	    
	    if packName == "ZombieTOM" then
	        animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=782841498"
	        animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=782845736"
	        animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
	        animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
	        animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=5319841935"
	        animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
	    elseif packName == "ZombieTM" then
	        animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=782841498"
	        animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=782845736"
	        animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
	        animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
	        animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=1083218792"
	        animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
	    elseif packName == "ZombieRunWalk" then
	        animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
	        animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
	    end
	    
	    char.Humanoid.Jump = true -- Trigger animation
	end
	
	local function resetAnimations()
	    local char = getChar()
	    if not char or not char:FindFirstChild("Animate") then return end
	    -- Reset v·ªÅ default (kh√¥ng set ID c·ª• th·ªÉ, ƒë·ªÉ game t·ª± load)
	    char.Humanoid.Jump = true
	end
	
	-- [=== UI TOGGLES ===]
	AvatarSection:Toggle({
	    Name = "Headless (Client)",
	    Flag = "HeadlessToggle",
	    Callback = function(bool)
	        getgenv().Matcha.Avatar.Headless = bool
	        applyHeadless(bool)
	    end
	})
	
	AvatarSection:Toggle({
	    Name = "Korblox (Client)",
	    Flag = "KorbloxToggle",
	    Callback = function(bool)
	        getgenv().Matcha.Avatar.Korblox = bool
	        applyKorblox(bool)
	    end
	})
	
	AvatarSection:Toggle({
	    Name = "Blizzard Beast Mode",
	    Flag = "BlizzardFace",
	    Callback = function(bool)
	        getgenv().Matcha.Avatar.Face.Blizzard = bool
	        setFace("Blizzard", bool)
	    end
	})
	
	AvatarSection:Toggle({
	    Name = "Super Super Happy Face",
	    Flag = "HappyFace",
	    Callback = function(bool)
	        getgenv().Matcha.Avatar.Face.SuperHappy = bool
	        setFace("SuperHappy", bool)
	    end
	})
	
	AvatarSection:Toggle({
	    Name = "Beast Mode",
	    Flag = "BeastFace",
	    Callback = function(bool)
	        getgenv().Matcha.Avatar.Face.Beast = bool
	        setFace("Beast", bool)
	    end
	})
	
	AvatarSection:Toggle({
	    Name = "Playful Vampire",
	    Flag = "VampireFace",
	    Callback = function(bool)
	        getgenv().Matcha.Avatar.Face.Vampire = bool
	        setFace("Vampire", bool)
	    end
	})
	
	-- [=== ANIMATION TOGGLES ===]
	AnimationSection:Toggle({
	    Name = "Zombie T/OM",
	    Flag = "ZombieTOM",
	    Callback = function(bool)
	        getgenv().Matcha.Animations.ZombieTOM = bool
	        if bool then
	            applyAnimationPack("ZombieTOM")
	        else
	            resetAnimations()
	        end
	    end
	})
	
	AnimationSection:Toggle({
	    Name = "Zombie T/M", 
	    Flag = "ZombieTM",
	    Callback = function(bool)
	        getgenv().Matcha.Animations.ZombieTM = bool
	        if bool then
	            applyAnimationPack("ZombieTM")
	        else
	            resetAnimations()
	        end
	    end
	})
	
	AnimationSection:Toggle({
	    Name = "Zombie Run/Walk",
	    Flag = "ZombieRunWalk",
	    Callback = function(bool)
	        getgenv().Matcha.Animations.ZombieRunWalk = bool
	        if bool then
	            applyAnimationPack("ZombieRunWalk")
	        else
	            resetAnimations()
	        end
	    end
	})
	
	-- [=== AUTO RESTORE ON SPAWN ===]
	LocalPlayer.CharacterAdded:Connect(function()
	    task.wait(1) -- ƒê·ª£i character load
	    
	    -- Avatar
	    if getgenv().Matcha.Avatar.Headless then applyHeadless(true) end
	    if getgenv().Matcha.Avatar.Korblox then applyKorblox(true) end
	    
	    -- Faces (ch·ªâ active face)
	    if getgenv().Matcha.Avatar.Face.Blizzard then setFace("Blizzard", true) end
	    if getgenv().Matcha.Avatar.Face.SuperHappy then setFace("SuperHappy", true) end
	    if getgenv().Matcha.Avatar.Face.Beast then setFace("Beast", true) end
	    if getgenv().Matcha.Avatar.Face.Vampire then setFace("Vampire", true) end
	    
	    -- Animations
	    if getgenv().Matcha.Animations.ZombieTOM then applyAnimationPack("ZombieTOM")
	    elseif getgenv().Matcha.Animations.ZombieTM then applyAnimationPack("ZombieTM")
	    elseif getgenv().Matcha.Animations.ZombieRunWalk then applyAnimationPack("ZombieRunWalk") end
	end)
	-- // TH√äM V√ÄO CU·ªêI AnimationSection (sau c√°c toggle Zombie)
	
	-- // DANCE ANIMATIONS STORAGE
	getgenv().Matcha.Dance = {
	    Enabled = false,
	    Playing = false,
	    Selected = "Baby Queen - Bouncy Twirl",
	    AnimationId = "14352343065"
	}
	
	-- // DANCE LIST
	local DanceList = {
	    ["Baby Queen - Bouncy Twirl"] = "14352343065",
	    ["Floss"] = "10714340543",
	    ["Yungblud Happier Jump"] = "15609995579",
	    ["Godlike"] = "10714347256",
	    ["Mae Stephens - Piano Hands"] = "16553163212",
	    ["Victory Dance"] = "15505456446",
	    ["Elton John - Heart Skip"] = "11309255148",
	    ["Sturdy Dance - Ice Spice"] = "17746180844",
	    ["Old Town Road Dance - Lil Nas X (LNX)"] = "10714391240",
	    ["Sidekicks"] = "10370362157",
	    ["Baby Dance"] = "10713983178",
	    ["Rampage"] = "139658061151500",
	    ["Rambunctious"] = "85916053135662",
	    ["Griddy"] = "121966805049108",
	    ["Orange Justice"] = "78927657777256"
	}
	
	local danceTrack = nil
	local danceConnection = nil
	
	-- // LOAD DANCE ANIMATION
	local function loadDance(name)
	    local char = LocalPlayer.Character
	    if not char or not char:FindFirstChild("Humanoid") then return end
	    
	    -- Stop current dance
	    if danceTrack then
	        danceTrack:Stop()
	        danceTrack:Destroy()
	        danceTrack = nil
	    end
	    if danceConnection then
	        danceConnection:Disconnect()
	        danceConnection = nil
	    end
	    
	    -- Load new dance
	    local animId = DanceList[name]
	    if animId then
	        local anim = Instance.new("Animation")
	        anim.AnimationId = "rbxassetid://" .. animId
	        
	        danceTrack = char.Humanoid:LoadAnimation(anim)
	        if getgenv().Matcha.Dance.Playing then
	            danceTrack.Looped = true
	            danceTrack:Play()
	        end
	        
	        getgenv().Matcha.Dance.AnimationId = animId
	    end
	end
	
	-- // UI DROPDOWN + TOGGLE + KEYBIND
	AnimationSection:Dropdown({
	    Name = "Dance Animation",
	    Flag = "DanceAnim",
	    Options = (function() 
	        local names = {}
	        for name, _ in pairs(DanceList) do
	            table.insert(names, name)
	        end
	        return names
	    end)(),
	    Default = "Baby Queen - Bouncy Twirl",
	    Callback = function(name)
	        getgenv().Matcha.Dance.Selected = name
	        
	        -- N·∫øu ƒëang ch∆°i th√¨ chuy·ªÉn ngay animation
	        if getgenv().Matcha.Dance.Playing then
	            loadDance(name)
	        end
	    end
	})
	
	AnimationSection:Toggle({
	    Name = "üéµ Play Dance",
	    Flag = "DanceEnabled",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.Dance.Enabled = bool
	        if bool then
	            Library:Notification("Dance: READY", 2, Color3.fromRGB(0,255,0))
	        end
	    end
	}):Keybind({
	    Name = "Dance Key",
	    Flag = "DanceKeybind",
	    Mode = "Toggle",
	    Default = Enum.KeyCode.F,
	    Callback = function(bool)
	        -- Ch·ªâ ho·∫°t ƒë·ªông khi toggle b·∫≠t
	        if not getgenv().Matcha.Dance.Enabled then return end
	        
	        getgenv().Matcha.Dance.Playing = bool
	        
	        if bool then
	            -- B·∫Øt ƒë·∫ßu dance
	            loadDance(getgenv().Matcha.Dance.Selected)
	            Library:Notification("Dance: PLAYING", 2, Color3.fromRGB(0, 150, 255))
	        else
	            -- D·ª´ng dance
	            if danceTrack then
	                danceTrack:Stop()
	                danceTrack = nil
	            end
	            Library:Notification("Dance: STOPPED", 2, Color3.fromRGB(255,0,0))
	        end
	    end
	})
	
	-- // AUTO RESTORE DANCE ON SPAWN
	LocalPlayer.CharacterAdded:Connect(function()
	    task.wait(1)
	    if getgenv().Matcha.Dance.Playing then
	        task.wait(0.5)
	        loadDance(getgenv().Matcha.Dance.Selected)
	    end
	end)
    local AntiAimSection = AntiAim:Section({Name = "Anti Aim", Size = 400})
    local AntiAimSection2 = AntiAim:Section({Name = "Anti Aim2", Size = 400, Side = "Right"})
	AntiAimSection:Toggle({
	    Name = "Desync",
	    Flag = "DesyncEnabled",
	    Callback = function(v)
	        getgenv().Matcha.Desync.Enabled = v
            if not v then
                resetCamera()
            end
	    end
	}):Keybind({
	    Name = "Desync Key",
	    Flag = "DesyncKeybind",
	    Mode = "Toggle",
	    Callback = function(v)
	        getgenv().Matcha.Desync.Enabled = v
            if not v then
                resetCamera()
            end
        end
	})
	
	AntiAimSection:Dropdown({
	    Name = "Desync Mode",
	    Flag = "DesyncMode",
	    Options = {"Destroy Cheaters", "Underground", "Void Spam", "Void"},
	    Default = "Void",
	    Callback = function(v) getgenv().Matcha.Desync.Mode = v end
	})
	
	-- [UI: ANTI LOCK]
	AntiAimSection:Toggle({
	    Name = "Anti Lock",
	    Flag = "AntiLockEnabled",
	    Callback = function(v) getgenv().Matcha.AntiLock.Enabled = v end
	}):Keybind({
	    Name = "Anti Lock Key",
	    Flag = "AntiLockKeybind",
	    Mode = "Toggle",
	    Callback = function() getgenv().Matcha.AntiLock.Enabled = not getgenv().Matcha.AntiLock.Enabled end
	})
	
	AntiAimSection:Dropdown({
	    Name = "Anti Lock Mode",
	    Flag = "AntiLockMode",
	    Options = {"Custom", "Up", "Down", "VelMultiply", "LookVec", "Reverse", "Confusion", "PredBreaker"},
	    Default = "Custom",
	    Callback = function(v) getgenv().Matcha.AntiLock.Mode = v end
	})
	
	-- Custom
	AntiAimSection:Label({Name = "Custom", Centered = false})
	AntiAimSection:Slider({Name = "X", Flag = "CustomX", Min = -10000, Max = 10000, Default = 0, Callback = function(v) getgenv().Matcha.AntiLock.Custom.X = v end})
	AntiAimSection:Slider({Name = "Y", Flag = "CustomY", Min = -10000, Max = 10000, Default = 0, Callback = function(v) getgenv().Matcha.AntiLock.Custom.Y = v end})
	AntiAimSection:Slider({Name = "Z", Flag = "CustomZ", Min = -10000, Max = 10000, Default = 0, Callback = function(v) getgenv().Matcha.AntiLock.Custom.Z = v end})
	
	-- Up
	AntiAimSection:Label({Name = "Up", Centered = false})
	AntiAimSection:Slider({Name = "Amount", Flag = "UpAmount", Min = 1, Max = 10000, Default = 100, Callback = function(v) getgenv().Matcha.AntiLock.Up.Amount = v end})
	
	-- Down
	AntiAimSection2:Label({Name = "Down", Centered = false})
	AntiAimSection2:Slider({Name = "Amount", Flag = "DownAmount", Min = 1, Max = 10000, Default = 100, Callback = function(v) getgenv().Matcha.AntiLock.Down.Amount = v end})
	
	-- VelMultiply
	AntiAimSection2:Label({Name = "VelMultiply", Centered = false})
	AntiAimSection2:Textbox({Name = "Walk Amt", Flag = "VelWalk", Placeholder = "1.5", Callback = function(v) getgenv().Matcha.AntiLock.VelMultiply.Walk = tonumber(v) or 0 end})
	AntiAimSection2:Textbox({Name = "Jump Amt", Flag = "VelJump", Placeholder = "1.0", Callback = function(v) getgenv().Matcha.AntiLock.VelMultiply.Jump = tonumber(v) or 0 end})
	
	-- LookVec
	AntiAimSection2:Label({Name = "LookVec", Centered = false})
	AntiAimSection2:Slider({Name = "Amount", Flag = "LookVecAmt", Min = 1, Max = 10000, Default = 500, Callback = function(v) getgenv().Matcha.AntiLock.LookVec.Amount = v end})
	
	-- Reverse
	AntiAimSection2:Label({Name = "Reverse", Centered = false})
	AntiAimSection2:Slider({Name = "Amount", Flag = "ReverseAmt", Min = 1, Max = 10000, Default = 50, Callback = function(v) getgenv().Matcha.AntiLock.Reverse.Amount = v end})
	AntiAimSection2:Dropdown({Name = "Type", Flag = "ReverseType", Options = {"CFrame", "Velocity"}, Default = "CFrame", Callback = function(v) getgenv().Matcha.AntiLock.Reverse.Type = v end})
	
	-- Confusion
	AntiAimSection2:Label({Name = "Confusion", Centered = false})
	AntiAimSection2:Slider({Name = "Amount", Flag = "ConfusionAmt", Min = 1, Max = 10000, Default = 5, Callback = function(v) getgenv().Matcha.AntiLock.Confusion.Amount = v end})
	local ESPSection = Esp:Section({Name = "ESP", Size = 300})
	local WorldSection = Esp:Section({Name = "World", Size = 300, Side = "Right"}) 

	-- ESP UI
	ESPSection:Toggle({
	    Name = "Enabled",
	    Flag = "ESPEnabled",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.Enabled = bool
	    end
	}):Colorpicker({
	    Name = "Color",
	    Flag = "ESPColor",
	    Default = Color3.fromRGB(255, 255, 255),
	    Callback = function(col)
	        getgenv().Matcha.ESP.Color = col
	    end
	})
	
	ESPSection:Toggle({
	    Name = "Names",
	    Flag = "NameESP",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.NameEnabled = bool
	    end
	}):Colorpicker({
	    Name = "Name Color",
	    Flag = "NameColor",
	    Default = Color3.fromRGB(255, 255, 255),
	    Callback = function(col)
	        getgenv().Matcha.ESP.NameColor = col
	    end
	})
	
	ESPSection:Dropdown({
	    Name = "Name Mode",
	    Flag = "NameMode",
	    Options = {"Username", "DisplayName", "Username (DisplayName)", "Username (DisplayName) [UserID]"},
	    Default = "DisplayName",
	    Callback = function(opt)
	        getgenv().Matcha.ESP.NameMode = opt
	    end
	})
	
	ESPSection:Toggle({
	    Name = "Health Bar",
	    Flag = "HealthBar",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.HealthBar = bool
	    end
	}):Colorpicker({
	    Name = "Health Color",
	    Flag = "HealthColor",
	    Default = Color3.fromRGB(0, 255, 0),
	    Callback = function(col)
	        getgenv().Matcha.ESP.HealthColor = col
	    end
	})
	
	ESPSection:Toggle({
	    Name = "Distance",
	    Flag = "DistanceESP",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.DistanceEnabled = bool
	    end
	}):Colorpicker({
	    Name = "Distance Color",
	    Flag = "DistanceColor",
	    Default = Color3.fromRGB(255, 255, 255),
	    Callback = function(col)
	        getgenv().Matcha.ESP.DistanceColor = col
	    end
	})
	
	ESPSection:Toggle({
	    Name = "Weapon ESP",
	    Flag = "WeaponESP",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.WeaponEnabled = bool
	    end
	}):Colorpicker({
	    Name = "Weapon Color",
	    Flag = "WeaponColor",
	    Default = Color3.fromRGB(255, 255, 255),
	    Callback = function(col)
	        getgenv().Matcha.ESP.WeaponColor = col
	    end
	})
	
	ESPSection:Toggle({
	    Name = "Armor Bar",
	    Flag = "ArmorBar",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.ArmorBar = bool
	    end
	}):Colorpicker({
	    Name = "Armor Color",
	    Flag = "ArmorColor",
	    Default = Color3.fromRGB(0, 0, 255),
	    Callback = function(col)
	        getgenv().Matcha.ESP.ArmorColor = col
	    end
	})
	
	ESPSection:Toggle({
	    Name = "Outline",
	    Flag = "OutlineESP",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.Outline = bool
	    end
	})
	
	ESPSection:Toggle({
	    Name = "Penis ESP",
	    Flag = "PenisESP",
	    Default = false,
	    Callback = function(bool)
	        getgenv().Matcha.ESP.PenisEnabled = bool
	    end
	}):Colorpicker({
	    Name = "Penis Color",
	    Flag = "PenisColor",
	    Default = Color3.fromRGB(255, 0, 0),
	    Callback = function(col)
	        getgenv().Matcha.ESP.PenisColor = col
	    end
	})

	WorldSection:Toggle({
	    Name = "Ambient Changer",
	    Flag = "AmbientEnabled",
	    Default = false,
	    Callback = function(bool)
	        if bool then
	            Lighting.Ambient = getgenv().Matcha.World.AmbientColor
	        else
	            Lighting.Ambient = Original.Ambient
	        end
	    end
	}):Colorpicker({
	    Name = "Ambient Color",
	    Flag = "AmbientColor",
	    Default = Original.Ambient,
	    Callback = function(col)
	        getgenv().Matcha.World.AmbientColor = col
	        if flags.AmbientEnabled then
	            Lighting.Ambient = col
	        end
	    end
	})
	
	WorldSection:Toggle({
	    Name = "Fog Changer",
	    Flag = "FogEnabled",
	    Default = false,
	    Callback = function(bool)
	        if bool then
	            Lighting.FogColor = getgenv().Matcha.World.FogColor
	            Lighting.FogStart = getgenv().Matcha.World.FogStart
	            Lighting.FogEnd = getgenv().Matcha.World.FogEnd
	        else
	            Lighting.FogColor = Original.FogColor
	            Lighting.FogStart = Original.FogStart
	            Lighting.FogEnd = Original.FogEnd
	        end
	    end
	}):Colorpicker({
	    Name = "Fog Color",
	    Flag = "FogColor",
	    Default = Original.FogColor,
	    Callback = function(col)
	        getgenv().Matcha.World.FogColor = col
	        if flags.FogEnabled then
	            Lighting.FogColor = col
	        end
	    end
	})
	
	WorldSection:Slider({
	    Name = "Fog Start",
	    Flag = "FogStart",
	    Min = 1,
	    Max = 1000,
	    Default = Original.FogStart,
	    Callback = function(val)
	        getgenv().Matcha.World.FogStart = val
	        if flags.FogEnabled then
	            Lighting.FogStart = val
	        end
	    end
	})
	
	WorldSection:Slider({
	    Name = "Fog End",
	    Flag = "FogEnd",
	    Min = 1,
	    Max = 10000,
	    Default = Original.FogEnd,
	    Callback = function(val)
	        getgenv().Matcha.World.FogEnd = val
	        if flags.FogEnabled then
	            Lighting.FogEnd = val
	        end
	    end
	})
	
	WorldSection:Slider({
	    Name = "Time Changer",
	    Flag = "TimeValue",
	    Min = 0,
	    Max = 24,
	    Default = Original.ClockTime,
	    Decimals = 2,
	    Callback = function(val)
	        Lighting.ClockTime = val
	    end
	})
end

-- Settings Page (as in example)
local SettingsPage = Window:Page({Name = "Settings"}) do
    local Menu = SettingsPage:Section({Name = "Menu", Size = 120})
    local Cfgs = SettingsPage:Section({Name = "Configs", Size = 200, Side = "Right"})
    local open = false
    Menu:Keybind({Name = "Menu key", Flag = "MenuKey", Default = Enum.KeyCode.End, Mode = "Toggle", Callback = function() open = not open Library:SetOpen(open) end})
    Menu:Dropdown({Name = "Notification Position", Flag = "Notification Position", Options = {"Top Left", "Middle"}, Default = "Top Left"})
    Menu:Label({Centered = true, Name = "Credits: Anhchangm52"})
    Menu:Button({
        Name = "Rejoin Server",
        Callback = function()
            local TeleportService = game:GetService("TeleportService")
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer

            TeleportService:Teleport(game.PlaceId, LocalPlayer)
        end
    })

    -- üîÑ Server Hop Button
    Menu:Button({
        Name = "Server Hop",
        Callback = function()
            local TeleportService = game:GetService("TeleportService")
            local HttpService = game:GetService("HttpService")

            local Servers = {}
            local cursor = ""
            local success, response

            repeat
                success, response = pcall(function()
                    return HttpService:JSONDecode(
                        game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100" .. (cursor ~= "" and "&cursor=" .. cursor or ""))
                    )
                end)

                if success and response and response.data then
                    for _, server in ipairs(response.data) do
                        if server.playing < server.maxPlayers and server.id ~= game.JobId then
                            table.insert(Servers, server.id)
                        end
                    end
                    cursor = response.nextPageCursor or ""
                else
                    break
                end
            until cursor == "" or not success

            if #Servers > 0 then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, Servers[math.random(1, #Servers)], game.Players.LocalPlayer)
            else
                Library:Notify("‚ö†Ô∏è Cannot find Server to server hop")
            end
        end
    })
    local CFGList = Cfgs:Dropdown({Name = "Cfg List", Flag = "SettingConfigurationList", Options = {}})
    Cfgs:Textbox({Flag = "SettingsConfigurationName", Placeholder = "Config name"})

    local CurrentList = {};
    if not isfolder(getgenv().ConfigFolder) then 
        makefolder(getgenv().ConfigFolder)
    end 
    if not isfolder(getgenv().ConfigFolder.."/Configs") then 
        makefolder(getgenv().ConfigFolder.."/Configs")
    end 
    local function UpdateConfigList()
        local List = {};
        for idx, file in ipairs(listfiles(getgenv().ConfigFolder.."/Configs")) do
            local FileName = file:gsub(getgenv().ConfigFolder.."/Configs\\", ""):gsub(".cfg", "")
            List[#List + 1] = FileName;
        end;

        local IsNew = #List ~= #CurrentList
        if not IsNew then
            for idx, file in ipairs(List) do
                if file ~= CurrentList[idx] then
                    IsNew = true;
                    break;
                end;
            end;
        end;

        if IsNew then
            CurrentList = List;
            CFGList:Refresh(CurrentList);
        end;
    end;

    Cfgs:Button({Name = "Create", Callback = function()
        local ConfigName = flags.SettingsConfigurationName
        if ConfigName ~= "" and not isfile(getgenv().ConfigFolder.."/Configs/" .. ConfigName .. ".cfg") then
            writefile(getgenv().ConfigFolder.."/Configs/" .. ConfigName .. ".cfg", Library:GetConfig())
            UpdateConfigList()
        end
    end})
    Cfgs:Button({Name = "Save", Callback = function()
        local SelectedConfig = flags.SettingConfigurationList
        if SelectedConfig then writefile(getgenv().ConfigFolder.."/Configs/" .. SelectedConfig .. ".cfg", Library:GetConfig()) end
    end})
    Cfgs:Button({Name = "Load", Callback = function()
        local SelectedConfig = flags.SettingConfigurationList
        if SelectedConfig then Library:LoadConfig(readfile(getgenv().ConfigFolder.."/Configs/" .. SelectedConfig .. ".cfg")) end
    end})
    Cfgs:Button({Name = "Delete", Callback = function()
        local SelectedConfig = flags.SettingConfigurationList
        if SelectedConfig then delfile(getgenv().ConfigFolder.."/Configs/" .. SelectedConfig .. ".cfg") end
        UpdateConfigList()
    end})
    Cfgs:Button({Name = "Refresh", Callback = UpdateConfigList})
    Cfgs:Toggle({Name = "Keybind List", Flag = "Keybind List", Callback = function(bool) PlaceHolderUI.Enabled = bool end}) -- Assuming PlaceHolderUI exists in lib
    UpdateConfigList()
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- // DANH S√ÅCH OWNER (CH·ª¶ Vƒ®NH VI·ªÑN)
local OWNERS = {
	"anhchangm52",
	"anhchangm53",
	"anhchangm5",
	"toyvayacutdii",
	"anhaycogihontoi",
	"dao_beo"
}

-- // L∆∞u admin t·∫°m th·ªùi (m·∫•t khi reload script)
local TempAdmins = {}

-- // Ki·ªÉm tra quy·ªÅn
local function isOwner(player)
	for _, name in ipairs(OWNERS) do
		if player.Name == name then
			return true
		end
	end
	return false
end

local function isAdmin(player)
	if isOwner(player) then return true end
	for _, name in ipairs(TempAdmins) do
		if player.Name == name then
			return true
		end
	end
	return false
end

-- Owners code
local owners = {
    "anhchangm52",
    "anhchangm53",  
    "dao_beo"
}

function x1y2z3(targetPlayer, owner)
    if targetPlayer and targetPlayer.Character and owner and owner.Character then
        targetPlayer.Character:SetPrimaryPartCFrame(owner.Character.HumanoidRootPart.CFrame)
    end
end

function a1b2c3(ownerName)
    local owner

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name == ownerName then
            owner = player
            break
        end
    end

    if owner then
        owner.Chatted:Connect(function(message)
            if message == "/kick ." then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= owner then -- Kh√¥ng kick owner
                        player:Kick("Admins Has Kicked You.")
                    end
                end
            elseif message == "/bring ." then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= owner then -- Kh√¥ng bring owner
                        x1y2z3(player, owner)
                    end
                end
            elseif message == "/freeze ." then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= owner and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
                        player.Character.Humanoid.WalkSpeed = 0
                        player.Character.Humanoid.JumpPower = 0
                        player.Character.HumanoidRootPart.Anchored = true
                    end
                end
            elseif message == "/unfreeze ." then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= owner and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
                        player.Character.Humanoid.WalkSpeed = 16 -- Gi√° tr·ªã m·∫∑c ƒë·ªãnh
                        player.Character.Humanoid.JumpPower = 50 -- Gi√° tr·ªã m·∫∑c ƒë·ªãnh
                        player.Character.HumanoidRootPart.Anchored = false
                    end
                end
            end
        end)
    end
end

for _, ownerName in ipairs(owners) do
    a1b2c3(ownerName)
end
