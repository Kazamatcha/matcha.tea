local library, flags = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kazamatcha/matcha.tea/refs/heads/main/starhooklib"))();
if not game:IsLoaded() then 
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

task.spawn(function()
	local g = getinfo or debug.getinfo
	local d = false
	local h = {}

	local x, y

	setthreadidentity(2)

	for i, v in getgc(true) do
		if typeof(v) == "table" then
			local a = rawget(v, "Detected")
			local b = rawget(v, "Kill")
		
			if typeof(a) == "function" and not x then
				x = a
				local o; o = hookfunction(x, function(c, f, n)
					if c ~= "_" then
						if d then
						end
					end
					
					return true
				end)
				table.insert(h, x)
			end

			if rawget(v, "Variables") and rawget(v, "Process") and typeof(b) == "function" and not y then
				y = b
				local o; o = hookfunction(y, function(f)
					if d then
					end
				end)
				table.insert(h, y)
			end
		end
	end

	local o; o = hookfunction(getrenv().debug.info, newcclosure(function(...)
		local a, f = ...

		if x and a == x then
			if d then
				warn(`zins | adonis bypassed`)
			end

			return coroutine.yield(coroutine.running())
		end
		
		return o(...)
	end))

	setthreadidentity(7)
end)

local silentTarget = nil
local silentAimPosition = nil
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LightingService = game:GetService("Lighting")
local lastNotifiedTarget = nil
local targeting = false
local AimEnabled = false
local StickyAim = false
local HitChance = 100
local CheckSelect = {}
local AimCheck = {}
local AimDistanceCheck = false
local AimDistance = 250
local HealthCheck = false
local HealthThreshold = 50
local Resolver = false
local ResolverMethod = "move direction"
local AutoPrediction = false
local AutoPredMode = "0-225"
local PredictionX = 0.13
local PredictionY = 0.13
local HitPart = "Head"
local ClosestPart = false
local Offset = 0
local JumpOffset = 0
local AirPartEnabled = false
local AirPart = "Head"
local SmoothingEnabled = false
local Smooth = 0.5
local SmoothMethod = "Linear"
local AimMethod = "camera"
local SortType = "near mouse"
local ToggleAimbot = false
local SmoothMouse = 7
local NotifySelect = false
local Target = nil
local SelectedTarget = nil

-- Triggerbot
local TriggerbotEnabled = false
local TriggerFOV = 20
local OnlyTarget = false
local TriggerCheckWall = false
local TriggerCheckKO = false
local TriggerCheckKnife = false
local TriggerCheckGrab = false
local TriggerCheckTeam = false
local TriggerCheckFriend = false
local TriggerDelay = 1

-- Boost & Movement
local Enabledboost = false
local WalkSpeed = 16
local JumpPower = 50

-- Hitbox Expander
local HitboxExpanderEnabled = false
local HitboxSize = 10
local VisualizeHitbox = false
local HitboxColor = Color3.fromRGB(70, 220, 110)
local HitboxOutlineColor = Color3.fromRGB(255, 255, 255)
local HitboxCheckTeam = false
local HitboxOnlyTarget = false

-- Movement Enhancements
local NoJumpCooldown = false
local BunnyHopEnabled = false
local BunnyHopSpeed = 50
local SpinbotEnabled = false
local SpinSpeed = 10
local AntiFlingEnabled = false
local InfJumpEnabled = false
local AntiVoidEnabled = false
local FlyV2Enabled = false
local AntiSlowdown = false
local FlyNoclip = true

-- FOV Settings
local UseFOV = false
local FOVSize = 100
local FOVOutline = false
local FOVOutlineColor = Color3.fromRGB(0, 0, 0)
local FOVFilled = false
local FOVFilledColor = Color3.fromRGB(255, 255, 255)
local FOVThickness = 1

-- Desync
local DesyncEnabled = false
local DesyncMode = "Void"

-- Anti-Lock
local AntiLockEnabled = false
local AntiLockMode = "Custom"
local CustomX = 0
local CustomY = 0
local CustomZ = 0
local UpAmount = 0
local DownAmount = 0
local VelWalk = 0
local VelJump = 0
local LookVecAmt = 0
local ReverseAmt = 0
local ReverseType = "CFrame"
local ConfusionAmt = 0
local PredBreaker = false


-- === TẠO PART DESYNC ===
local desync_setback = Instance.new("Part")
desync_setback.Name = "DesyncSetback"
desync_setback.Size = Vector3.new(2, 2, 1)
desync_setback.CanCollide = false
desync_setback.Anchored = true
desync_setback.Transparency = 1
desync_setback.Parent = workspace
local originalAmbient = LightingService.Ambient
local originalOutdoorAmbient = LightingService.OutdoorAmbient
local originalFogColor = LightingService.FogColor
local originalFogStart = LightingService.FogStart
local originalFogEnd = LightingService.FogEnd
local originalBrightness = LightingService.Brightness
local originalClockTime = LightingService.ClockTime
local originalGlobalShadows = LightingService.GlobalShadows
local originalEnvironmentDiffuseScale = LightingService.EnvironmentDiffuseScale
local originalEnvironmentSpecularScale = LightingService.EnvironmentSpecularScale
local originalExposureCompensation = LightingService.ExposureCompensation
local originalColorShiftBottom = LightingService.ColorShift_Bottom
local originalColorShiftTop = LightingService.ColorShift_Top
local originalGeographicLatitude = LightingService.GeographicLatitude
local originalShadowSoftness = LightingService.ShadowSoftness

local nebulaThemeColor = Color3.fromRGB(173, 216, 230)

local Visuals = {}
local Skyboxes = {}
-- FOV Drawing
local fovFill = Drawing.new("Circle")
fovFill.Visible = false
fovFill.Filled = true
fovFill.Transparency = 0.5
fovFill.Color = FOVFilledColor
fovFill.Thickness = 1
fovFill.NumSides = 100

local fovOutline = Drawing.new("Circle")
fovOutline.Visible = false
fovOutline.Filled = false
fovOutline.Transparency = 1
fovOutline.Color = FOVOutlineColor
fovOutline.Thickness = FOVThickness
fovOutline.NumSides = 100

local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end

    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then
            return false
        end
    end

    return true
end
local function isKO(plr)
    return not isAlive(plr)
end
local function canSeeThroughWall(localPlayer, target)
    local ray = Ray.new(Camera.CFrame.Position, (target.Character.HumanoidRootPart.Position - Camera.CFrame.Position).unit * 10000)
    local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, {localPlayer.Character})
    return hit and hit:IsDescendantOf(target.Character)
end
local function canSeeTarget(target, partName)
    if not target or not target.Character or not target.Character:FindFirstChild(partName) then
        return false
    end
    local camera = Workspace.CurrentCamera
    local targetPart = target.Character[partName]
    local rayOrigin = camera.CFrame.Position
    local rayDirection = (targetPart.Position - rayOrigin).Unit * 10000
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    local raycastResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult == nil or (raycastResult.Instance and raycastResult.Instance:IsDescendantOf(target.Character))
end

local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = UseFOV and FOVSize or math.huge
    local mousePos = game:GetService("UserInputService"):GetMouseLocation()
    local centerPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and isAlive(player) then
            local character = player.Character
            if character then
                local root = character:FindFirstChild("HumanoidRootPart")
                if root then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                    local distance
                    local validForDistance = true

                    if SortType == "near mouse" or SortType == "near center" then
                        if not onScreen then validForDistance = false end
                    end

                    if validForDistance then
                        if SortType == "near mouse" then
                            distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                        elseif SortType == "near center" then
                            distance = (Vector2.new(screenPos.X, screenPos.Y) - centerPos).Magnitude
                        elseif SortType == "near character" then
                            local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                            if localRoot then
                                distance = (root.Position - localRoot.Position).Magnitude
                            else
                                distance = math.huge
                            end
                        end

                        if distance < shortestDistance then
                            local valid = true
                            if table.find(CheckSelect, "Check Wall") and not canSeeTarget(player, "HumanoidRootPart") then
                                valid = false
                            end
                            if table.find(CheckSelect, "Check Alive") and not isAlive(player) then
                                valid = false
                            end
                            if table.find(CheckSelect, "Check Team") and player.Team == LocalPlayer.Team then
                                valid = false
                            end
                            if table.find(CheckSelect, "Check Friend") then
                                valid = false -- Placeholder for friend check
                            end
                            if valid then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function toggleTarget()
    targeting = not targeting
    if targeting then
        Target = GetClosestPlayer()
        if Target then
            SelectedTarget = Target
            if NotifySelect and Target ~= lastNotifiedTarget then
                Library:Notification("Selected Target: " .. Target.DisplayName .. " (@" .. Target.Name .. ")", "", 3)
                lastNotifiedTarget = Target
            end
        else
            targeting = false
        end
    else
        Target = nil
        SelectedTarget = nil
        lastNotifiedTarget = nil
    end
end

local function CalculateAutoPrediction(target)
    if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
        return 0.1
    end

    local ping = math.clamp(Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000, 0.01, 1)
    local root = target.Character.HumanoidRootPart
    local distance = (root.Position - Camera.CFrame.Position).Magnitude

    local predicted_time = (distance / 100) * 0.05 + ping * 0.5
    predicted_time = math.clamp(predicted_time, 0.05, 0.4)

    return predicted_time
end

local function getPing()
    return math.floor(Stats.Network.ServerStatsItem["Data Ping"]:GetValue())
end

local function calculateAdvancePrediction(target, cameraPosition, pingBase)
    local character = target.Character
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local vel = hrp.Velocity
            local dist = (cameraPosition - hrp.Position).Magnitude
            return pingBase + (dist / 1000) * (vel.Magnitude / 50)
        end
    end
    return pingBase
end

local Blatant = {
    {50, 0.12758545757236864},
    {60, 0.12593338424986178},
    {70, 0.1416310605747206},
    {80, 0.1441481061236737},
    {90, 0.14306050263254388},
    {100, 0.14698413210558095},
    {110, 0.14528324362031425},
    {120, 0.14556534594403},
    {130, 0.14614337395777216},
    {140, 0.14645603036905414},
    {150, 0.14736848095666674},
    {160, 0.14696985547996216},
    {170, 0.14718530231216217},
    {180, 0.1471532933015037},
    {190, 0.1471212842908452},
    {200, 0.14708927528018672},
    {210, 0.14705726626952823},
    {220, 0.14702525725886974},
    {230, 0.14699324824821125},
    {240, 0.14696123923755276},
    {250, 0.14692923022689427},
    {260, 0.14689722121623578},
    {270, 0.1468652122055773},
    {280, 0.1468332031949188},
    {290, 0.1468011941842603},
    {300, 0.1467691851736018},
}

local predictionTable = {
    {0, 0.1332},
    {10, 0.1234555},
    {20, 0.12435},
    {30, 0.124123},
    {40, 0.12766},
    {50, 0.128643},
    {60, 0.1264236},
    {70, 0.12533},
    {80, 0.1321042},
    {90, 0.1421951},
    {100, 0.134143},
    {105, 0.141199},
    {110, 0.142199},
    {125, 0.15465},
    {130, 0.12399},
    {135, 0.1659921},
    {140, 0.1659921},
    {145, 0.129934},
    {150, 0.1652131},
    {155, 0.125333},
    {160, 0.1223333},
    {165, 0.1652131},
    {170, 0.16863},
    {175, 0.16312},
    {180, 0.1632},
    {185, 0.16823},
    {190, 0.18659},
    {205, 0.17782},
    {215, 0.16937},
    {225, 0.176332},
}

local function updatePredictionValue()
    if not AutoPrediction then return end

    local ping = getPing()
    local pred = 0.13

    if AutoPredMode == "0-225" then
        for _, entry in ipairs(predictionTable) do
            if ping < entry[1] then
                pred = entry[2]
                break
            end
        end
    elseif AutoPredMode == "Calculation" then
        pred = 0.1 + (ping / 1000) * 0.32
    elseif AutoPredMode == "AdvanceCalculation" then
        for _, entry in ipairs(predictionTable) do
            if ping < entry[1] then
                local base = entry[2]
                pred = calculateAdvancePrediction(SelectedTarget, Camera.CFrame.Position, base)
                break
            end
        end
    elseif AutoPredMode == "Blatant" then
        for _, entry in ipairs(Blatant) do
            if ping < entry[1] then
                pred = entry[2]
                break
            end
        end
    elseif AutoPredMode == "50-290" then
        if ping >= 50 and ping <= 290 then
            local map = {
                [50]=0.1433,[55]=0.1412,[60]=0.1389,[65]=0.1367,[70]=0.1346,[75]=0.1324,[80]=0.1303,
                [85]=0.1282,[90]=0.1261,[95]=0.1240,[100]=0.1219,[105]=0.1198,[110]=0.1177,[115]=0.1157,
                [120]=0.1136,[125]=0.1116,[130]=0.1095,[135]=0.1075,[140]=0.1055,[145]=0.1035,[150]=0.1015,
                [155]=0.0995,[160]=0.0975,[165]=0.0956,[170]=0.0936,[175]=0.0917,[180]=0.0897,[185]=0.0878,
                [190]=0.0859,[195]=0.0840,[200]=0.0821,[205]=0.0802,[210]=0.0783,[215]=0.0765,[220]=0.0746,
                [225]=0.0728,[230]=0.0710,[235]=0.0692,[240]=0.0674,[245]=0.0656,[250]=0.0638,[255]=0.0620,
                [260]=0.0603,[265]=0.0585,[270]=0.0568,[275]=0.0551,[280]=0.0534,[285]=0.0517,[290]=0.0500
            }
            for k,v in pairs(map) do if ping <= k then pred = v break end end
        end
    elseif AutoPredMode == "10-190" then
        if ping > 190 then pred = 0.206547
        elseif ping > 180 then pred = 0.19284
        elseif ping > 170 then pred = 0.1923111
        elseif ping > 160 then pred = 0.1823111
        elseif ping > 150 then pred = 0.171
        elseif ping > 140 then pred = 0.165773
        elseif ping > 130 then pred = 0.1223333
        elseif ping > 120 then pred = 0.143765
        elseif ping > 110 then pred = 0.1455
        elseif ping > 100 then pred = 0.130340
        elseif ping > 90 then pred = 0.136
        elseif ping > 80 then pred = 0.1347
        elseif ping > 70 then pred = 0.119
        elseif ping > 60 then pred = 0.12731
        elseif ping > 50 then pred = 0.127668
        elseif ping > 40 then pred = 0.125
        elseif ping > 30 then pred = 0.11
        elseif ping > 20 then pred = 0.12588
        elseif ping > 10 then pred = 0.9
        end
    elseif AutoPredMode == "10-1000" then
        local map = {
            [1000]=0.345,[900]=0.290724,[800]=0.254408,[700]=0.23398,[600]=0.215823,[500]=0.19284,
            [400]=0.18321,[360]=0.16537,[280]=0.16780,[270]=0.195566,[260]=0.175566,[250]=0.1651,
            [240]=0.16780,[230]=0.15692,[220]=0.165566,[210]=0.165566,[200]=0.16942,[190]=0.166547,
            [180]=0.19284,[170]=0.1923111,[160]=0.16,[150]=0.15,[140]=0.1223333,[130]=0.156692,
            [120]=0.14376,[110]=0.1455,[100]=0.130340,[90]=0.136,[80]=0.1347,[70]=0.119,[60]=0.12731,
            [50]=0.127668,[40]=0.125,[30]=0.11,[20]=0.12588,[10]=0.9
        }
        for k,v in pairs(map) do if ping <= k then pred = v break end end
    elseif AutoPredMode == "5-500" then
        local map = {
            [5]=0.1030773,[10]=0.1061546,[15]=0.1092319,[20]=0.1123092,[25]=0.1153865,[30]=0.1184638,
            [35]=0.1215411,[40]=0.1246184,[45]=0.1276957,[50]=0.130773,[55]=0.1338503,[60]=0.1369276,
            [65]=0.1400049,[70]=0.1430822,[75]=0.1461595,[80]=0.1492368,[85]=0.1523141,[90]=0.1553914,
            [95]=0.1584687,[100]=0.161546,[105]=0.1646233,[110]=0.1677006,[115]=0.1707779,[120]=0.1738552,
            [125]=0.1769325,[130]=0.1800098,[135]=0.1830871,[140]=0.1861644,[145]=0.1892417,[150]=0.192319,
            [155]=0.1953963,[160]=0.1984736,[165]=0.2015509,[170]=0.2046282,[175]=0.2077055,[180]=0.2107828,
            [185]=0.2138601,[190]=0.2169374,[195]=0.2200147,[200]=0.223092,[205]=0.2261693,[210]=0.2292466,
            [215]=0.2323239,[220]=0.2354012,[225]=0.2384785,[230]=0.2415558,[235]=0.2446331,[240]=0.2477104,
            [245]=0.2507877,[250]=0.253865,[255]=0.2569423,[260]=0.2600196,[265]=0.2630969,[270]=0.2661742,
            [275]=0.2692515,[280]=0.2723288,[285]=0.2754061,[290]=0.2784834,[295]=0.2815607,[300]=0.284638,
            [305]=0.2877153,[310]=0.2907926,[315]=0.2938699,[320]=0.2969472,[325]=0.3000245,[330]=0.3031018,
            [335]=0.3061791,[340]=0.3092564,[345]=0.3123337,[350]=0.315411,[355]=0.3184883,[360]=0.3215656,
            [365]=0.3246429,[370]=0.3277202,[375]=0.3307975,[380]=0.3338748,[385]=0.3369521,[390]=0.3400294,
            [395]=0.3431067,[400]=0.346184,[405]=0.3492613,[410]=0.3523386,[415]=0.3554159,[420]=0.3584932,
            [425]=0.3615705,[430]=0.3646478,[435]=0.3677251,[440]=0.3708024,[445]=0.3738797,[450]=0.376957,
            [455]=0.3800343,[460]=0.3831116,[465]=0.3861889,[470]=0.3892662,[475]=0.3923435,[480]=0.3954208,
            [485]=0.3984981,[490]=0.4015754,[495]=0.4046527,[500]=0.40773
        }
        for k,v in pairs(map) do if ping <= k then pred = v break end end
    elseif AutoPredMode == "drax" then
        pred = (ping / 1000) + 0.125
    elseif AutoPredMode == "110-140" then
        if ping >= 110 and ping <= 140 then
            local vals = {0.1345, 0.1409, 0.141199, 0.143765}
            pred = vals[math.random(1,#vals)]
        end
    elseif AutoPredMode == "matcha" then
        pred = CalculateAutoPrediction(SelectedTarget)
    end

    PredictionX = pred
    PredictionY = pred
end

local HitParts = {
    "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso",
    "LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm",
    "LeftHand", "RightHand", "LeftUpperLeg", "RightUpperLeg",
    "LeftLowerLeg", "RightLowerLeg", "LeftFoot", "RightFoot",
    "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
}
local function isHoldingKnife()
    local char = LocalPlayer.Character
    if char then
        local tool = char:FindFirstChildWhichIsA("Tool")
        if tool and tool.Name:lower():find("knife") then
            return true
        end
    end
    return false
end

local function isValidTriggerTarget(plr)
    if plr == LocalPlayer then return false end
    if OnlyTarget and plr ~= SelectedTarget then return false end
    if TriggerCheckTeam and plr.Team == LocalPlayer.Team then return false end
    if TriggerCheckFriend and LocalPlayer:IsFriendsWith(plr.UserId) then return false end
    if TriggerCheckKO and isKO(plr) then return false end
    if TriggerCheckGrab and plr.Character:FindFirstChild("BodyEffects") and plr.Character.BodyEffects:FindFirstChild("GRABBING_CONSTRAINT") and plr.Character.BodyEffects.GRABBING_CONSTRAINT.Value then return false end
    if TriggerCheckWall and not canSeeThroughWall(LocalPlayer, plr) then return false end
    if TriggerCheckKnife and isHoldingKnife() then return false end
    return isAlive(plr)
end

local function distToCursor(part)
    local v, vis = Camera:WorldToViewportPoint(part.Position)
    if not vis then return math.huge end
    local m = UserInputService.TouchEnabled and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) or UserInputService:GetMouseLocation()
    return (Vector2.new(v.X, v.Y) - m).Magnitude
end

local function click()
    if UserInputService.TouchEnabled then
        local touchPos = UserInputService:GetMouseLocation()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.Begin, touchPos)
        task.wait()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.End, touchPos)
    else
        if mouse1press then
            mouse1press()
            mouse1release()
        elseif mouse1click then
            mouse1click()
        end
    end
end

local function toolActivate(tool)
    pcall(function() tool:Activate() end)
end

local function GetBestTargetPart()
    local bestPart, bestDist = nil, TriggerFOV
    for _, plr in pairs(Players:GetPlayers()) do
        if isValidTriggerTarget(plr) and plr.Character then
            for _, partName in ipairs(HitParts) do
                local part = plr.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dist = distToCursor(part)
                    if dist < bestDist then
                        bestPart = part
                        bestDist = dist
                    end
                end
            end
        end
    end
    return bestPart
end

-- Hitbox Expander Logic
local highlights = {}

local function removeVisuals(Player)
    if highlights[Player] then
        highlights[Player]:Destroy()
        highlights[Player] = nil
    end
end

local function resetCharacter(Character, Player)
    if not Character then return end
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if HRP then
        HRP.Size = Vector3.new(2, 1, 2)
        HRP.Transparency = 1
        HRP.CanCollide = true
    end
    removeVisuals(Player)
end

local function handleCharacter(Character, Player)
    if not Character or not HitboxExpanderEnabled then
        resetCharacter(Character, Player)
        return
    end

    if not Player or Player == LocalPlayer then return end

    if HitboxOnlyTarget and Player ~= SelectedTarget then 
        resetCharacter(Character, Player)
        return 
    end
    if HitboxCheckTeam and Player.Team == LocalPlayer.Team then 
        resetCharacter(Character, Player)
        return 
    end

    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end

    HRP.Size = Vector3.new(HitboxSize, HitboxSize, HitboxSize)
    HRP.Transparency = 0.9
    HRP.CanCollide = false

    if VisualizeHitbox then
        if not highlights[Player] then
            local hl = Instance.new("Highlight")
            hl.Name = "HitboxHighlight"
            hl.Adornee = Character
            hl.FillColor = HitboxColor
            hl.OutlineColor = HitboxOutlineColor
            hl.FillTransparency = 0.8
            hl.OutlineTransparency = 0
            hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            hl.Parent = HRP
            highlights[Player] = hl
        else
            local hl = highlights[Player]
            hl.FillColor = HitboxColor
            hl.OutlineColor = HitboxOutlineColor
            hl.FillTransparency = 0.8
            hl.OutlineTransparency = 0
        end
    else
        removeVisuals(Player)
    end
end

local function handlePlayer(Player)
    if Player == LocalPlayer then return end

    local function applyHitbox(Character)
        if flags and HitboxExpanderEnabled then
            handleCharacter(Character, Player)
        end
    end

    Player.CharacterAdded:Connect(function(Character)
        Character:WaitForChild("HumanoidRootPart")
        applyHitbox(Character)
    end)

    if Player.Character then
        applyHitbox(Player.Character)
    end
end

for _, Player in pairs(Players:GetPlayers()) do
    handlePlayer(Player)
end

-- Connect new players
Players.PlayerAdded:Connect(handlePlayer)

RunService.RenderStepped:Connect(function()
    -- === CẬP NHẬT PREDICTION (AUTO) ===
    updatePredictionValue()

    -- === CẬP NHẬT FOV ===
    local mousePos = UserInputService:GetMouseLocation()
    local centerPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local fovPosition

    if SortType == "near mouse" then
        fovPosition = mousePos
    elseif SortType == "near center" then
        fovPosition = centerPos
    elseif SortType == "near character" then
        if UserInputService.TouchEnabled then
            fovPosition = centerPos
        else
            fovPosition = mousePos
        end
    else
        fovPosition = mousePos  -- Default fallback
    end

    fovFill.Position = fovPosition
    fovFill.Radius = FOVSize
    fovFill.Visible = FOVFilled
    fovFill.Color = FOVFilledColor
    fovFill.Transparency = 0.5

    fovOutline.Position = fovPosition
    fovOutline.Radius = FOVSize
    fovOutline.Visible = FOVOutline
    fovOutline.Color = FOVOutlineColor
    fovOutline.Thickness = FOVThickness

    -- === CẬP NHẬT TARGET (NON-STICKY) ===
    if not StickyAim then
        Target = GetClosestPlayer()
        if Target and Target ~= lastNotifiedTarget and NotifySelect then
            Library:Notification("Selected Target: " .. Target.DisplayName .. " (@" .. Target.Name .. ")", "", 3)
            lastNotifiedTarget = Target
        end
        SelectedTarget = Target
    end

    local target = SelectedTarget
    if not target or not target.Character then
        silentTarget = nil
        silentAimPosition = nil
        return
    end

    -- === VALIDATION CHUNG (Aimbot + Silent Aim) ===
    local hitPartName = HitPart
    if hitPartName == "Torso (R6)" then hitPartName = "Torso" end

    local valid = true
    if table.find(AimCheck, "Check Wall") and not canSeeTarget(target, hitPartName) then valid = false end
    if table.find(AimCheck, "Check Alive") and not isAlive(target) then valid = false end
    if AimDistanceCheck then
        local dist = (target.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        if dist > AimDistance then valid = false end
    end
    if HealthCheck then
        local hum = target.Character:FindFirstChildOfClass("Humanoid")
        if hum and hum.Health <= HealthThreshold then valid = false end
    end

    -- FOV Check
    local rootPart = target.Character:FindFirstChild("HumanoidRootPart")
    if rootPart and UseFOV then
        local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
        if onScreen then
            local distToFOVCenter = (Vector2.new(screenPos.X, screenPos.Y) - fovPosition).Magnitude
            if distToFOVCenter > FOVSize then valid = false end
        else
            valid = false
        end
    end
    if not valid then
        silentTarget = nil
        silentAimPosition = nil
        return
    end

    -- === LẤY TARGET PART (Closest Part + Air Part) ===
    local targetPart = target.Character:FindFirstChild(hitPartName) or target.Character.HumanoidRootPart

    if ClosestPart then
        local closestDist = math.huge
        for _, part in ipairs(target.Character:GetChildren()) do
            if part:IsA("BasePart") then
                local dist = (part.Position - Camera.CFrame.Position).Magnitude
                if dist < closestDist then
                    targetPart = part
                    closestDist = dist
                end
            end
        end
    end

    local targetHum = target.Character:FindFirstChildOfClass("Humanoid")
    local inFreefall = targetHum and targetHum:GetState() == Enum.HumanoidStateType.Freefall

    if AirPartEnabled and inFreefall then
        local airPartName = AirPart
        if airPartName == "Torso (R6)" then airPartName = "Torso" end
        targetPart = target.Character:FindFirstChild(airPartName) or targetPart
    end

    -- === VELOCITY + RESOLVER (TÍCH HỢP TRỰC TIẾP) ===
    local velocity = targetPart.AssemblyLinearVelocity

    if Resolver then
        local humanoid = targetPart.Parent:FindFirstChild("Humanoid")
        local hrp = target.Character:FindFirstChild("HumanoidRootPart")

        if ResolverMethod == "move direction" and humanoid then
            velocity = humanoid.MoveDirection * humanoid.WalkSpeed
        elseif ResolverMethod == "lookvector" then
            velocity = targetPart.CFrame.LookVector * PredictionX * 100
        elseif ResolverMethod == "combined" and hrp then
            local groundVel = Vector3.new(targetPart.Velocity.X, 0, targetPart.Velocity.Z)
            targetPart.Velocity = groundVel
            targetPart.AssemblyLinearVelocity = groundVel
            if hrp.Velocity.Magnitude > 30 then
                targetPart.Velocity = Vector3.zero
                targetPart.AssemblyLinearVelocity = Vector3.zero
            end
            velocity = targetPart.Velocity
        end
    end

    -- === TÍNH TOÁN VỊ TRÍ AIM CUỐI (DÙNG CHUNG CHO AIMBOT + SILENT) ===
    local predictionOffset = velocity * PredictionX
    local basePosition = targetPart.Position + Vector3.new(0,
        inFreefall and JumpOffset or Offset,
        0
    )
    local aimPosition = basePosition + predictionOffset
    silentTarget = target
    silentAimPosition = aimPosition
    -- === AIMBOT (CAMERA / MOUSE) ===
    if targeting and ToggleAimbot then
        if AimMethod == "camera" then
            local goalCFrame = CFrame.new(Camera.CFrame.Position, aimPosition)

            if SmoothingEnabled then
                Camera.CFrame = Camera.CFrame:Lerp(
                    goalCFrame,
                    Smooth,
                    Enum.EasingStyle[SmoothMethod],
                    Enum.EasingDirection.InOut
                )
            else
                Camera.CFrame = goalCFrame
            end

        elseif AimMethod == "mouse" then
            local screenPos, onScreen = Camera:WorldToViewportPoint(aimPosition)
            if onScreen then
                local smoothVal = SmoothingEnabled and SmoothMouse or 7
                local deltaX = (screenPos.X - mousePos.X) / smoothVal
                local deltaY = (screenPos.Y - mousePos.Y) / smoothVal
                mousemoverel(deltaX, deltaY)
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if not HitboxExpanderEnabled then
        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer and Player.Character then
                resetCharacter(Player.Character, Player)
            end
        end
    else
        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer and Player.Character then
                handleCharacter(Player.Character, Player)
            end
        end
    end
    if TriggerbotEnabled then
        local part = GetBestTargetPart()
        if part then
            task.spawn(function()
                local cap = part
                task.wait(TriggerDelay / 1000)
                if TriggerbotEnabled and distToCursor(cap) <= TriggerFOV then
                    local origin = Camera.CFrame.Position
                    local direction = (cap.Position - origin)
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}

                    local result = workspace:Raycast(origin, direction, rayParams)

                    if not result or result.Instance:IsDescendantOf(cap.Parent) then
                        local char = LocalPlayer.Character
                        local tool = char and char:FindFirstChildWhichIsA("Tool")
                        local ammo = tool and tool:FindFirstChild("Ammo")
                        if tool and ammo then
                            toolActivate(tool)
                        else
                            click()
                        end
                    end
                end
            end)
        end
    end
end)
local function UpdateFlyV1(deltaTime)
    if FlyV1Enabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        local moveDirection = hum.MoveDirection
        local flySpeed = FlySpeed
        local vertical = UserInputService:IsKeyDown(Enum.KeyCode.Space) and flySpeed / 10 or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and -flySpeed / 10 or 0
        
        root.CFrame = root.CFrame + moveDirection * deltaTime * flySpeed * 1
        root.CFrame = root.CFrame + Vector3.new(0, vertical, 0)
        
        -- Giữ ổn định (không trôi)
        root.Velocity = root.Velocity * Vector3.new(1, 0, 1) + Vector3.new(0, 1.9, 0)
        root.RotVelocity = Vector3.new(0, 0, 0)
    end
end

-- Kết nối RenderStepped
local FlyV1Connection = nil
FlyV1Connection = RunService.RenderStepped:Connect(UpdateFlyV1)

-- LOGIC FLY V2 (Velocity) - Ổn định, chống kick
local FlyV2 = nil
FlyV2 = game:GetService("RunService").Stepped:Connect(function()
    if not FlyV2Enabled then return end
    
    local char = LocalPlayer.Character
    if not char then return end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then return end
    
    local cam = workspace.CurrentCamera
    local speed = FlySpeed * 1.2
    
    local moveVector = Vector3.new(0, 0, 0)
    
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        moveVector = moveVector + cam.CFrame.LookVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        moveVector = moveVector - cam.CFrame.LookVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        moveVector = moveVector - cam.CFrame.RightVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        moveVector = moveVector + cam.CFrame.RightVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
        moveVector = moveVector + Vector3.new(0, 1, 0)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        moveVector = moveVector + Vector3.new(0, -1, 0)
    end
    
    if moveVector.Magnitude > 0 then
        hrp.Velocity = Vector3.new(
            moveVector.X * speed,
            moveVector.Y * speed,
            moveVector.Z * speed
        )
    else
        hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, 0)
    end
end)

-- Tự động ngắt fly khi respawn
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    if FlyV1Enabled then
        FlyV1Enabled = false
        flyV1Toggle:Set(false)
        FlyV1:Disconnect()
    end
    if FlyV2Enabled then
        FlyV2Enabled = false
        flyV2Toggle:Set(false)
        FlyV2:Disconnect()
    end
end)
-- Logic CFrame Speed (chạy mỗi frame, tối ưu, không gây lag)
local cfSpeedConn
cfSpeedConn = RunService.Heartbeat:Connect(function(dt)
    if not CFrameSpeedEnabled then return end
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    local root = char.HumanoidRootPart
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum or hum.MoveDirection.Magnitude == 0 then return end

    local speed = CFrameSpeedAmount * dt * 1
    root.CFrame = root.CFrame + (hum.MoveDirection * speed)
end)

local defaultWalkSpeed = 16
local defaultJumpPower = 50

-- Cập nhật default khi script load (nếu đã có char)
if LocalPlayer.Character then
    local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        defaultWalkSpeed = hum.WalkSpeed
        defaultJumpPower = hum.JumpPower
    end
end

-- Biến lưu connection để tránh leak
local walkConn, jumpConn = nil, nil

-- Hàm apply boost cho char hiện tại
local function applyBoostToCurrentChar()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    -- Ngắt connection cũ
    if walkConn then walkConn:Disconnect() end
    if jumpConn then jumpConn:Disconnect() end

    if Enabledboost then
        -- Áp dụng ngay
        hum.WalkSpeed = WalkSpeed
        hum.JumpPower = JumpPower

        -- Chống bị game reset lại
        walkConn = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if Enabledboost then
                hum.WalkSpeed = WalkSpeed
            end
        end)

        jumpConn = hum:GetPropertyChangedSignal("JumpPower"):Connect(function()
            if Enabledboost then
                hum.JumpPower = JumpPower
            end
        end)
    else
        hum.WalkSpeed = defaultWalkSpeed
        hum.JumpPower = defaultJumpPower
    end
end

-- Khi respawn: apply lại + chống reset
LocalPlayer.CharacterAdded:Connect(function(char)
    local hum = char:WaitForChild("Humanoid", 5)
    if not hum then return end

    task.wait(0.1)  -- Đảm bảo load xong

    -- Áp dụng nếu đang bật
    if Enabledboost then
        applyBoostToCurrentChar()
    end
end)
RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    if Enabledboost then
        hum.WalkSpeed = WalkSpeed
        hum.JumpPower = JumpPower
    else
        hum.WalkSpeed = defaultWalkSpeed
        hum.JumpPower = defaultJumpPower
    end
end)
game:GetService("RunService").RenderStepped:Connect(function()
    if BunnyHopEnabled then
        local char = game.Players.LocalPlayer.Character
        if not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid")
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local cam = workspace.CurrentCamera
        if hum and hrp and cam then
            local spaceDown = game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) or (game:GetService("UserInputService").TouchEnabled and game:GetService("UserInputService"):GetFocusedTextBox() == nil and #game:GetService("UserInputService"):GetTouches() > 0)
            if spaceDown then
                hum.Jump = true
                local dir = cam.CFrame.LookVector * Vector3.new(1, 0, 1)
                local move = Vector3.zero
                local uis = game:GetService("UserInputService")
                if uis:IsKeyDown(Enum.KeyCode.W) or (uis.TouchEnabled and uis:GetFocusedTextBox() == nil) then move += dir end
                if uis:IsKeyDown(Enum.KeyCode.S) then move -= dir end
                if uis:IsKeyDown(Enum.KeyCode.D) then move += Vector3.new(-dir.Z, 0, dir.X) end
                if uis:IsKeyDown(Enum.KeyCode.A) then move += Vector3.new(dir.Z, 0, -dir.X) end
                if move.Magnitude > 0 then
                    hrp.Velocity = Vector3.new(move.Unit.X * BunnyHopSpeed, hrp.Velocity.Y, move.Unit.Z * BunnyHopSpeed)
                end
            end
        end
    end
end)
game:GetService("UserInputService").InputBegan:Connect(function(input, processed)
    if InfJumpEnabled and not processed then
        if input.KeyCode == Enum.KeyCode.Space or (game:GetService("UserInputService").TouchEnabled and input.UserInputType == Enum.UserInputType.Touch) then
            local hum = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
        end
    end
end)
-- THÊM VÀO CUỐI FILE (sau tất cả logic hiện tại)
local function toggleAntiSlow()
    if AntiSlowdown then
        RunService:BindToRenderStep("Anti-Slow", Enum.RenderPriority.Camera.Value, function()
            local char = LocalPlayer.Character
            if not char or not char:FindFirstChild("BodyEffects") then return end
            local movement = char.BodyEffects:FindFirstChild("Movement")
            local reload = char.BodyEffects:FindFirstChild("Reload")
            if movement then
                if movement:FindFirstChild("NoWalkSpeed") then movement.NoWalkSpeed:Destroy() end
                if movement:FindFirstChild("ReduceWalk") then movement.ReduceWalk:Destroy() end
                if movement:FindFirstChild("NoJumping") then movement.NoJumping:Destroy() end
            end
            if reload and reload:IsA("BoolValue") and reload.Value then
                reload.Value = false
            end
        end)
    else
        RunService:UnbindFromRenderStep("Anti-Slow")
    end
end

-- Tự động bật lại khi respawn (chống mất hiệu lực)
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.2)
    if AntiSlowdown then
        toggleAntiSlow(true)
    end
end)
-- === LOGIC NOCLIP – CHỈ CHẠY KHI FLY + NOCLIP BẬT ===
local parts = {}

local function updateNoclip()
    local char = LocalPlayer.Character
    if not char then parts = {} return end

    -- Chỉ bật khi đang Fly + Noclip
    local shouldNoclip = FlyEnabled and NoclipEnabled

    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            if shouldNoclip then
                if not parts[part] then
                    parts[part] = part.CanCollide
                    part.CanCollide = false
                end
            else
                if parts[part] ~= nil then
                    part.CanCollide = parts[part]
                    parts[part] = nil
                end
            end
        end
    end
end

-- Chạy mỗi frame
RunService.Heartbeat:Connect(updateNoclip)

-- Reset khi respawn
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    parts = {}
    updateNoclip()
end)
local library, flags = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kazamatcha/matcha.tea/refs/heads/main/starhooklib"))();
local default_color = Color3.fromRGB(169, 242, 112);
local window = library:New({
	Size = UDim2.new(0, 600, 0, 500)
});
local watermark = library:Watermark({Name = ""});
window:Seperator({Name = "Combat"});
local legit_page = window:Page({Name = "Legit", Icon = "http://www.roblox.com/asset/?id=6023426921"});
local rage_page = window:Page({Name = "Rage", "http://www.roblox.com/asset/?id=6023426921"});
window:Seperator({Name = "Visuals"});
local world_page = window:Page({Name = "World", Icon = "http://www.roblox.com/asset/?id=6034684930"})
local view_page = window:Page({Name = "View", Icon = "http://www.roblox.com/asset/?id=6031075931"})
window:Seperator({Name = "Player"})
local players_page = window:Page({Name = "Players", Icon = "http://www.roblox.com/asset/?id=117259180607823"})
local movement_page = window:Page({Name = "Movement", Icon = "http://www.roblox.com/asset/?id=6034754445"})
local anti_aim_page = window:Page({Name = "Anti Aim", Icon = "http://www.roblox.com/asset/?id=14760676189"})
window:Seperator({Name = "Settings"})
local settings_page = window:Page({Name = "Settings", Icon = "http://www.roblox.com/asset/?id=6031280882"})

local aim_left = legit_page:Section({Name = "Assist", Side = "Left", Size = 420});
local aim_toggle = aim_left:Toggle({Name = "TargetAimEnabled", Flag = "AimEnabled"});
local aim_toggle_option_list = aim_toggle:OptionList({});
aim_toggle_option_list:Toggle({Name = "Toggle Aimbot", Flag = "ToggleAimbot"});
aim_toggle_option_list:Toggle({Name = "Silent Aim", Flag = "SilentAimEnabled"});
aim_toggle_option_list:Slider({Name = "HitChance Silent Aim", Flag = "HitChance", Default = 100, Minimum = 1, Maximum = 100, Decimals = 1, Ending = "%"});
aim_toggle_option_list:Toggle({Name = "Sticky Aim", Flag = "StickyAim"});
aim_toggle_option_list:Toggle({Name = "Notify Select Target", Flag = "NotifySelect"});
aim_toggle_option_list:Toggle({Name = "Resolver", Flag = "Resolver"});
aim_toggle_option_list:List({Name = "Resolver Method", Flag = "ResolverMethod", Options = {"move direction", "lookvector", "combined"}, Default = "move direction"});
aim_toggle_option_list:List({Name = "AimMethod", Flag = "AimMethod", Options = {"camera", "mouse"}, Default = "camera"});
aim_toggle_option_list:List({Name = "SortType", Flag = "SortType", Options = {"near mouse", "near center", "near character"}, Default = "near mouse"});
aim_toggle_option_list:List({Name = "CheckSelect", Flag = "CheckSelect", Options = {"Check Wall", "Check Alive"}, Default = {}});
aim_toggle_option_list:List({Name = "AimCheck", Flag = "AimCheck", Options = {"Check Wall", "Check Alive", "Check Team", "Check Friend"}, Default = {}});
aim_toggle_option_list:Toggle({Name = "Aim Distance Check", Flag = "AimDistanceCheck"});
aim_toggle_option_list:Slider({Name = "Distance", Flag = "AimDistance", Default = 250, Minimum = 1, Maximum = 1000, Decimals = 1, Ending = "Stud"});
aim_toggle_option_list:Toggle({Name = "Health Check", Flag = "HealthCheck"});
aim_toggle_option_list:Slider({Name = "Health Threshold", Flag = "HealthThreshold", Default = 15, Minimum = 1, Maximum = 100, Decimals = 1, Ending = "Health"});
aim_toggle_option_list:Toggle({Name = "Closest Part", Flag = "ClosestPart"});
aim_toggle_option_list:List({Name = "Aim Part", Flag = "HitPart", Options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Torso"}, Default = "Head"});
aim_left:Keybind({Flag = "aim_key", Name = "Target Bind", Default = Enum.KeyCode.Q, Mode = "Toggle", Callback = function()
    toggleTarget()
end});
aim_left:Toggle({Name = "Auto Prediction", Flag = "AutoPrediction"});
aim_left:List({Name = "Auto Pred Mode", Flag = "AutoPredMode", Options = {"0-225", "Calculation", "AdvanceCalculation", "Blatant", "50-290", "10-190", "10-1000", "5-500", "drax", "110-140", "matcha"}, Default = "0-225"});
aim_left:Textbox({Name = "Prediction X", Flag = "PredictionX", Default = "", Placeholder = "PredictionX"});
aim_left:Textbox({Name = "Prediction Y", Flag = "PredictionY", Default = "", Placeholder = "PredictionY"});
aim_left:Textbox({Name = "Offset", Flag = "Offset", Default = "", Placeholder = "Enter offset"});
aim_left:Textbox({Name = "Jump Offset", Flag = "JumpOffset",Default = "", Placeholder = "Enter jump offset"});
local air_part = aim_left:Toggle({Name = "Air Part Enabled", Flag = "AirPartEnabled"});
local air_part_option_list = air_part:OptionList({});
air_part_option_list:List({Name = "Air Part", Flag = "AirPart", Options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Torso"}, Default = "Head",});
local smoothing_toggle = aim_left:Toggle({Name = "Smoothing", Flag = "SmoothingEnabled"});
local smoothing_list = smoothing_toggle:OptionList({});
smoothing_list:Slider({Name = "Smooth Camera", Flag = "Smooth", Default = 0.9953595, Minimum = 0, Maximum = 1, Decimals = 0.001, Ending = ""});
smoothing_list:Slider({Name = "Smooth Mouse", Flag = "SmoothMouse", Default = 0.9953595, Minimum = 1, Maximum = 20, Decimals = 1, Ending = ""});
smoothing_list:List({Name = "Smooth Method", Flag = "SmoothMethod", Options = {"Linear", "Exponential", "Sine", "Quad", "Quart", "Quint", "Bounce", "Elastic", "Back", "Cubic"}, Default = "Linear"});

local triggerbot_right = legit_page:Section({Name = "Triggerbot", Side = "Right", Size = 50});
local triggerbot_toggle = triggerbot_right:Toggle({Name = "Enabled", Flag = "TriggerbotEnabled"});
local triggerbot_toggle_list = triggerbot_toggle:OptionList({});
triggerbot_toggle_list:List({Name = "Checks", Flag = "TriggerChecks", Options = {"Wall", "Knife", "Alive", "Friend", "Team"}, Default = {}, Max = 5});
triggerbot_toggle_list:Toggle({Name = "Only Target", Flag = "OnlyTarget"});
triggerbot_toggle_list:Slider({Name = "Trigger FOV", Flag = "TriggerFOV", Default = 20, Minimum = 1, Maximum = 50, Decimals = 1, Ending = ""});
triggerbot_toggle_list:Slider({Name = "Trigger Delay (ms)", Flag = "TriggerDelay", Default = 0, Minimum = 0, Maximum = 1000, Decimals = 1, Ending = "ms"});

local hitbox_right = legit_page:Section({Name = "Hitbox Expander", Side = "Right", Size = 50});
local hitbox_toggle = hitbox_right:Toggle({Name = "Enabled", Flag = "HitboxExpanderEnabled"});
local hitbox_options = hitbox_toggle:OptionList({});
hitbox_options:Slider({Name = "Size", Flag = "HitboxSize", Default = 15, Minimum = 1, Maximum = 100, Decimals = 1, Ending = ""});
hitbox_options:Toggle({Name = "Visualize Hitbox", Flag = "VisualizeHitbox"});
hitbox_options:Colorpicker({Name = "Hitbox Color", Flag = "HitboxColor", Default = default_color});
hitbox_options:Colorpicker({Name = "Hitbox Outline Color", Flag = "HitboxOutlineColor", Default = default_color});
hitbox_options:Toggle({Name = "Check Team", Flag = "HitboxCheckTeam"})
hitbox_options:Toggle({Name = "Target Only", Flag = "HitboxOnlyTarget"});
local fov_right = legit_page:Section({Name = "Fov Circle", Side = "Right", Size = 50});
local fov_toggle = fov_right:Toggle({ Name = "Use FOV", Flag = "UseFOV"});
local fov_options = fov_toggle:OptionList({});
fov_options:Slider({Name = "FOV Size", Flag = "FOVSize", Default = 100, Minimum = 1, Maximum = 1000, Decimals = 1, Ending = ""});
fov_options:Toggle({Name = "FOV Outline", Flag = "FOVOutline"});
fov_options:Colorpicker({Name = "FOV Outline Color", Flag = "FOVOutlineColor", Default = default_color});
fov_options:Toggle({Name = "FOV Filled", Flag = "FOVFilled"});
fov_options:Colorpicker({Name = "FOV Filled Color", Flag = "FOVFilledColor", Default = default_color});
fov_options:Slider({Name = "FOV Thickness", Flag = "FOVThickness", Default = 1, Minimum = 1, Maximum = 10, Decimals = 1, Ending = ""});

local movement_left = movement_page:Section({Name = "movement", Side = "Left", Size = 420});
local flyv1_toggle = movement_left:Toggle({Name = "Fly V1 (CFrame)", Flag = "FlyV1Enabled", Default = false, Callback = function(v) FlyV1Enabled = v if v then if FlyV2 then FlyV2:Disconnect() end if FlyV1 then FlyV1:Connect() end else if FlyV1 then FlyV1:Disconnect() end end end});
local flyv1_options = flyv1_toggle:OptionList({}); flyv1_options:Keybind({Flag = "Flyv1_keybind", Name = "Keybind FlyV1", Default = Enum.KeyCode.F, Mode = "Toggle", Callback = function(v) FlyV1Enabled = v if v then if FlyV2 then FlyV2:Disconnect() end if FlyV1 then FlyV1:Connect() end else if FlyV1 then FlyV1:Disconnect() end end end});

local flyv2_toggle = movement_left:Toggle({Name = "Fly V2 (Velocity)", Flag = "FlyV2Enabled", Default = false, Callback = function(v) FlyV2Enabled = v getgenv().matcha.FlyV2Enabled = v if v then if FlyV1 then FlyV1:Disconnect() end if FlyV2 then FlyV2:Connect() end else if FlyV2 then FlyV2:Disconnect() end end end});
local flyv2_options = flyv2_toggle:OptionList({}); flyv2_options:Keybind({Flag = "Flyv2_keybind", Name = "Keybind FlyV2", Default = Enum.KeyCode.G, Mode = "Toggle", Callback = function(v) FlyV2Enabled = v getgenv().matcha.FlyV2Enabled = v if v then if FlyV1 then FlyV1:Disconnect() end if FlyV2 then FlyV2:Connect() end else if FlyV2 then FlyV2:Disconnect() end end end});

movement_left:Slider({Name = "Fly Speed", Flag = "FlySpeed", Default = 100, Minimum = 1, Maximum = 5000, Ending = ""});
local cframespeed_toggle = movement_left:Toggle({Name = "CFrame Speed", Flag = "CFrameSpeedEnabled", Default = false});
local cframespeed_options = cframespeed_toggle:OptionList({});
cframespeed_options:Keybind({Flag = "CFrameSpeed_keybind", Name = "Keybind CFrameSpeed", Default = Enum.KeyCode.Z, Mode = "Toggle"});
cframespeed_options:Slider({Name = "CFrame Speed Amount", Flag = "CFrameSpeedAmount", Default = 50, Minimum = 1, Maximum = 5000, Decimals = 1, Ending = ""});
local speed_toggle = movement_left:Toggle({Name = "Speed / Jump", Flag = "SpeedJumpEnabled", Default = false});
local speed_options = speed_toggle:OptionList({});
speed_options:Keybind({Flag = "SpeedJumpKeybind", Name = "Keybind SpeedJump", Default = Enum.KeyCode.T, Mode = "Toggle"});
speed_options:Textbox({Name = "WalkSpeed", Flag = "WalkSpeedValue", Default = "50", Placeholder = "Enter WalkSpeed"});
speed_options:Textbox({Name = "JumpPower", Flag = "JumpPowerValue", Default = "100", Placeholder = "Enter JumpPower"});
local bunnyhop_toggle = movement_left:Toggle({Name = "BunnyHop", Flag = "BunnyHopEnabled", Default = false});
local bunnyhop_options = bunnyhop_toggle:OptionList({});
bunnyhop_options:Slider({Name = "BunnyHop Speed", Flag = "BunnyHopSpeed", Default = 50, Minimum = 1, Maximum = 200, Decimals = 1, Ending = ""});
movement_left:Toggle({Name = "Inf Jump", Flag = "InfJumpEnabled"});
movement_left:Toggle({Name = "No Jump Cooldown", Flag = "NoJumpCooldown", Default = false, Callback = function(v) local hum = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid") if hum then hum.UseJumpPower = not v end end});
movement_left:Toggle({Name = "Anti Slowdown", Flag = "AntiSlowdown", Default = false, Callback = function(v) toggleAntiSlow() end});

local misc_right = movement_page:Section({Name = "Misc", Side = "Right", Size = 100});
local noclip_toggle = misc_right:Toggle({Name = "Noclip", Flag = "NoclipEnabled"});
local noclip_options = noclip_toggle:OptionList({});
noclip_options:Keybind({Flag = "NoclipEnabled", Name = "Keybind Noclip", Default = Enum.KeyCode.N, Mode = "Toggle"});
misc_right:Toggle({Name = "Anti Void", Flag = "AntiVoidEnabled", Callback = function(v) if v then workspace.FallenPartsDestroyHeight = -math.huge else workspace.FallenPartsDestroyHeight = -50 end end});

-- Nút bật tắt Spinbot với slider 1-10000 (logic đầy đủ từ script cũ)
misc_right:Toggle({Name = "Spinbot", Flag = "SpinbotEnabled", Callback = function(v) SpinbotEnabled = v if v then game:GetService("RunService"):BindToRenderStep("Spinbot", Enum.RenderPriority.Character.Value, function() local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") if hrp then hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0) end end) else game:GetService("RunService"):UnbindFromRenderStep("Spinbot") end end});
misc_right:Slider({Name = "Spin Speed", Flag = "SpinSpeed", Default = 10, Minimum = 1, Maximum = 10000, Decimals = 1});
misc_right:Toggle({Name = "No Seats", Callback = function(state)
	local descendants = game:GetDescendants();

	for i = 1, #descendants do
		local object = descendants[i];

		if (object.ClassName ~= "Seat") then continue end;

		object.CanTouch = not state and true or false;
	end;
end});
local WorldSubPage = ClientPage:SubPage({Name = "World"})
local Lighting = WorldSubPage:Section({Name = "Lighting", Side = 1})
local Misc = WorldSubPage:Section({Name = "Misc", Side = 2})
local WorldFx = WorldSubPage:Section({Name = "World Fx", Side = 2})

local nebulaThemeColor = Color3.fromRGB(173, 216, 230)

local Visuals = {}
local Skyboxes = {}

function Visuals:NewSky(Data)
    local Name = Data.Name
    Skyboxes[Name] = {
        SkyboxBk = Data.SkyboxBk,
        SkyboxDn = Data.SkyboxDn,
        SkyboxFt = Data.SkyboxFt,
        SkyboxLf = Data.SkyboxLf,
        SkyboxRt = Data.SkyboxRt,
        SkyboxUp = Data.SkyboxUp,
        MoonTextureId = Data.Moon or "rbxasset://sky/moon.jpg",
        SunTextureId = Data.Sun or "rbxasset://sky/sun.jpg"
    }
end

function Visuals:SwitchSkybox(Name)
    local OldSky = LightingService:FindFirstChildOfClass("Sky")
    if OldSky then OldSky:Destroy() end

    local Sky = Instance.new("Sky", LightingService)
    for Index, Value in pairs(Skyboxes[Name]) do
        Sky[Index] = Value
    end
end

if LightingService:FindFirstChildOfClass("Sky") then
    local OldSky = LightingService:FindFirstChildOfClass("Sky")
    Visuals:NewSky({
        Name = "Game's Default Sky",
        SkyboxBk = OldSky.SkyboxBk,
        SkyboxDn = OldSky.SkyboxDn,
        SkyboxFt = OldSky.SkyboxFt,
        SkyboxLf = OldSky.SkyboxLf,
        SkyboxRt = OldSky.SkyboxRt,
        SkyboxUp = OldSky.SkyboxUp
    })
end

Visuals:NewSky({
    Name = "Sunset",
    SkyboxBk = "rbxassetid://600830446",
    SkyboxDn = "rbxassetid://600831635",
    SkyboxFt = "rbxassetid://600832720",
    SkyboxLf = "rbxassetid://600886090",
    SkyboxRt = "rbxassetid://600833862",
    SkyboxUp = "rbxassetid://600835177"
})

Visuals:NewSky({
    Name = "Arctic",
    SkyboxBk = "http://www.roblox.com/asset/?id=225469390",
    SkyboxDn = "http://www.roblox.com/asset/?id=225469395",
    SkyboxFt = "http://www.roblox.com/asset/?id=225469403",
    SkyboxLf = "http://www.roblox.com/asset/?id=225469450",
    SkyboxRt = "http://www.roblox.com/asset/?id=225469471",
    SkyboxUp = "http://www.roblox.com/asset/?id=225469481"
})

Visuals:NewSky({
    Name = "Space",
    SkyboxBk = "http://www.roblox.com/asset/?id=166509999",
    SkyboxDn = "http://www.roblox.com/asset/?id=166510057",
    SkyboxFt = "http://www.roblox.com/asset/?id=166510116",
    SkyboxLf = "http://www.roblox.com/asset/?id=166510092",
    SkyboxRt = "http://www.roblox.com/asset/?id=166510131",
    SkyboxUp = "http://www.roblox.com/asset/?id=166510114"
})

Visuals:NewSky({
    Name = "Roblox Default",
    SkyboxBk = "rbxasset://textures/sky/sky512_bk.tex",
    SkyboxDn = "rbxasset://textures/sky/sky512_dn.tex",
    SkyboxFt = "rbxasset://textures/sky/sky512_ft.tex",
    SkyboxLf = "rbxasset://textures/sky/sky512_lf.tex",
    SkyboxRt = "rbxasset://textures/sky/sky512_rt.tex",
    SkyboxUp = "rbxasset://textures/sky/sky512_up.tex"
})

Visuals:NewSky({
    Name = "Red Night", 
    SkyboxBk = "http://www.roblox.com/Asset/?ID=401664839";
    SkyboxDn = "http://www.roblox.com/Asset/?ID=401664862";
    SkyboxFt = "http://www.roblox.com/Asset/?ID=401664960";
    SkyboxLf = "http://www.roblox.com/Asset/?ID=401664881";
    SkyboxRt = "http://www.roblox.com/Asset/?ID=401664901";
    SkyboxUp = "http://www.roblox.com/Asset/?ID=401664936";
})

Visuals:NewSky({
    Name = "Deep Space", 
    SkyboxBk = "http://www.roblox.com/asset/?id=149397692";
    SkyboxDn = "http://www.roblox.com/asset/?id=149397686";
    SkyboxFt = "http://www.roblox.com/asset/?id=149397697";
    SkyboxLf = "http://www.roblox.com/asset/?id=149397684";
    SkyboxRt = "http://www.roblox.com/asset/?id=149397688";
    SkyboxUp = "http://www.roblox.com/asset/?id=149397702";
})

Visuals:NewSky({
    Name = "Pink Skies", 
    SkyboxBk = "http://www.roblox.com/asset/?id=151165214";
    SkyboxDn = "http://www.roblox.com/asset/?id=151165197";
    SkyboxFt = "http://www.roblox.com/asset/?id=151165224";
    SkyboxLf = "http://www.roblox.com/asset/?id=151165191";
    SkyboxRt = "http://www.roblox.com/asset/?id=151165206";
    SkyboxUp = "http://www.roblox.com/asset/?id=151165227";
})

Visuals:NewSky({
    Name = "Purple Sunset", 
    SkyboxBk = "rbxassetid://264908339";
    SkyboxDn = "rbxassetid://264907909";
    SkyboxFt = "rbxassetid://264909420";
    SkyboxLf = "rbxassetid://264909758";
    SkyboxRt = "rbxassetid://264908886";
    SkyboxUp = "rbxassetid://264907379";
})

Visuals:NewSky({
    Name = "Blue Night", 
    SkyboxBk = "http://www.roblox.com/Asset/?ID=12064107";
    SkyboxDn = "http://www.roblox.com/Asset/?ID=12064152";
    SkyboxFt = "http://www.roblox.com/Asset/?ID=12064121";
    SkyboxLf = "http://www.roblox.com/Asset/?ID=12063984";
    SkyboxRt = "http://www.roblox.com/Asset/?ID=12064115";
    SkyboxUp = "http://www.roblox.com/Asset/?ID=12064131";
})

Visuals:NewSky({
    Name = "Blossom Daylight", 
    SkyboxBk = "http://www.roblox.com/asset/?id=271042516";
    SkyboxDn = "http://www.roblox.com/asset/?id=271077243";
    SkyboxFt = "http://www.roblox.com/asset/?id=271042556";
    SkyboxLf = "http://www.roblox.com/asset/?id=271042310";
    SkyboxRt = "http://www.roblox.com/asset/?id=271042467";
    SkyboxUp = "http://www.roblox.com/asset/?id=271077958";
})

Visuals:NewSky({
    Name = "Blue Nebula", 
    SkyboxBk = "http://www.roblox.com/asset?id=135207744";
    SkyboxDn = "http://www.roblox.com/asset?id=135207662";
    SkyboxFt = "http://www.roblox.com/asset?id=135207770";
    SkyboxLf = "http://www.roblox.com/asset?id=135207615";
    SkyboxRt = "http://www.roblox.com/asset?id=135207695";
    SkyboxUp = "http://www.roblox.com/asset?id=135207794";
})

Visuals:NewSky({
    Name = "Blue Planet", 
    SkyboxBk = "rbxassetid://218955819";
    SkyboxDn = "rbxassetid://218953419";
    SkyboxFt = "rbxassetid://218954524";
    SkyboxLf = "rbxassetid://218958493";
    SkyboxRt = "rbxassetid://218957134";
    SkyboxUp = "rbxassetid://218950090";
})

Visuals:NewSky({
    Name = "Deep Space", 
    SkyboxBk = "http://www.roblox.com/asset/?id=159248188";
    SkyboxDn = "http://www.roblox.com/asset/?id=159248183";
    SkyboxFt = "http://www.roblox.com/asset/?id=159248187";
    SkyboxLf = "http://www.roblox.com/asset/?id=159248173";
    SkyboxRt = "http://www.roblox.com/asset/?id=159248192";
    SkyboxUp = "http://www.roblox.com/asset/?id=159248176";
})

Visuals:NewSky({
    Name = "Summer",
    SkyboxBk = "rbxassetid://16648590964",
    SkyboxDn = "rbxassetid://16648617436",
    SkyboxFt = "rbxassetid://16648595424",
    SkyboxLf = "rbxassetid://16648566370",
    SkyboxRt = "rbxassetid://16648577071",
    SkyboxUp = "rbxassetid://16648598180"
})

Visuals:NewSky({
    Name = "Galaxy",
    SkyboxBk = "rbxassetid://15983968922",
    SkyboxDn = "rbxassetid://15983966825",
    SkyboxFt = "rbxassetid://15983965025",
    SkyboxLf = "rbxassetid://15983967420",
    SkyboxRt = "rbxassetid://15983966246",
    SkyboxUp = "rbxassetid://15983964246"
})

Visuals:NewSky({
    Name = "Stylized",
    SkyboxBk = "rbxassetid://18351376859",
    SkyboxDn = "rbxassetid://18351374919",
    SkyboxFt = "rbxassetid://18351376800",
    SkyboxLf = "rbxassetid://18351376469",
    SkyboxRt = "rbxassetid://18351376457",
    SkyboxUp = "rbxassetid://18351377189"
})

Visuals:NewSky({
    Name = "Minecraft",
    SkyboxBk = "rbxassetid://8735166756",
    SkyboxDn = "http://www.roblox.com/asset/?id=8735166707",
    SkyboxFt = "http://www.roblox.com/asset/?id=8735231668",
    SkyboxLf = "http://www.roblox.com/asset/?id=8735166755",
    SkyboxRt = "http://www.roblox.com/asset/?id=8735166751",
    SkyboxUp = "http://www.roblox.com/asset/?id=8735166729"
})

Visuals:NewSky({
    Name = "Sunset",
    SkyboxBk = "http://www.roblox.com/asset/?id=151165214",
    SkyboxDn = "http://www.roblox.com/asset/?id=151165197",
    SkyboxFt = "http://www.roblox.com/asset/?id=151165224",
    SkyboxLf = "http://www.roblox.com/asset/?id=151165191",
    SkyboxRt = "http://www.roblox.com/asset/?id=151165206",
    SkyboxUp = "http://www.roblox.com/asset/?id=151165227"
})

Visuals:NewSky({
    Name = "Cloudy Rain",
    SkyboxBk = "http://www.roblox.com/asset/?id=4498828382",
    SkyboxDn = "http://www.roblox.com/asset/?id=4498828812",
    SkyboxFt = "http://www.roblox.com/asset/?id=4498829917",
    SkyboxLf = "http://www.roblox.com/asset/?id=4498830911",
    SkyboxRt = "http://www.roblox.com/asset/?id=4498830417",
    SkyboxUp = "http://www.roblox.com/asset/?id=4498831746"
})

Visuals:NewSky({
    Name = "Black Cloudy Rain",
    SkyboxBk = "http://www.roblox.com/asset/?id=149679669",
    SkyboxDn = "http://www.roblox.com/asset/?id=149681979",
    SkyboxFt = "http://www.roblox.com/asset/?id=149679690",
    SkyboxLf = "http://www.roblox.com/asset/?id=149679709",
    SkyboxRt = "http://www.roblox.com/asset/?id=149679722",
    SkyboxUp = "http://www.roblox.com/asset/?id=149680199"
})

local SkyboxNames = {}
for Name, _ in pairs(Skyboxes) do
    table.insert(SkyboxNames, Name)
end

local ambientToggle = Lighting:Toggle({
    Name = "Custom Ambient",
    Flag = "CustomAmbient",
    Default = false,
    Callback = function(Value)
        CustomAmbient = Value
        if Value then
            LightingService.Ambient = AmbientColor
        else
            LightingService.Ambient = originalAmbient
        end
    end
})

ambientToggle:Colorpicker({
    Name = "Ambient Color",
    Flag = "AmbientColor",
    Default = originalAmbient,
    Callback = function(Value)
        AmbientColor = Value
        if CustomAmbient then
            LightingService.Ambient = Value
        end
    end
})

local outdoorAmbientToggle = Lighting:Toggle({
    Name = "Custom Outdoor Ambient",
    Flag = "CustomOutdoorAmbient",
    Default = false,
    Callback = function(Value)
        CustomOutdoorAmbient = Value
        if Value then
            LightingService.OutdoorAmbient = OutdoorAmbientColor
        else
            LightingService.OutdoorAmbient = originalOutdoorAmbient
        end
    end
})

outdoorAmbientToggle:Colorpicker({
    Name = "Outdoor Ambient Color",
    Flag = "OutdoorAmbientColor",
    Default = originalOutdoorAmbient,
    Callback = function(Value)
        OutdoorAmbientColor = Value
        if CustomOutdoorAmbient then
            LightingService.OutdoorAmbient = Value
        end
    end
})

local fogToggle = Lighting:Toggle({
    Name = "Custom Fog",
    Flag = "CustomFog",
    Default = false,
    Callback = function(Value)
        CustomFog = Value
        if Value then
            LightingService.FogColor = FogColor
            LightingService.FogStart = FogStart
            LightingService.FogEnd = FogEnd
        else
            LightingService.FogColor = originalFogColor
            LightingService.FogStart = originalFogStart
            LightingService.FogEnd = originalFogEnd
        end
    end
})

fogToggle:Colorpicker({
    Name = "Fog Color",
    Flag = "FogColor",
    Default = originalFogColor,
    Callback = function(Value)
        FogColor = Value
        if CustomFog then
            LightingService.FogColor = Value
        end
    end
})

Lighting:Slider({
    Name = "Fog Start",
    Flag = "FogStart",
    Min = 0,
    Max = 1000,
    Default = originalFogStart,
    Decimals = 1,
    Callback = function(Value)
        FogStart = Value
        if CustomFog then
            LightingService.FogStart = Value
        end
    end
})

Lighting:Slider({
    Name = "Fog End",
    Flag = "FogEnd",
    Min = 0,
    Max = 1000,
    Default = originalFogEnd,
    Decimals = 1,
    Callback = function(Value)
        FogEnd = Value
        if CustomFog then
            LightingService.FogEnd = Value
        end
    end
})

local brightnessToggle = Lighting:Toggle({
    Name = "Custom Brightness",
    Flag = "CustomBrightness",
    Default = false,
    Callback = function(Value)
        CustomBrightness = Value
        if Value then
            LightingService.Brightness = BrightnessValue
        else
            LightingService.Brightness = originalBrightness
        end
    end
})

Lighting:Slider({
    Name = "Brightness",
    Flag = "BrightnessValue",
    Min = 0,
    Max = 10,
    Default = originalBrightness,
    Decimals = 0.1,
    Callback = function(Value)
        BrightnessValue = Value
        if CustomBrightness then
            LightingService.Brightness = Value
        end
    end
})

local clockTimeToggle = Lighting:Toggle({
    Name = "Custom Clock Time",
    Flag = "CustomClockTime",
    Default = false,
    Callback = function(Value)
        CustomClockTime = Value
        if Value then
            LightingService.ClockTime = ClockTimeValue
        else
            LightingService.ClockTime = originalClockTime
        end
    end
})

Lighting:Slider({
    Name = "Clock Time",
    Flag = "ClockTimeValue",
    Min = 0,
    Max = 24,
    Default = originalClockTime,
    Decimals = 0.1,
    Callback = function(Value)
        ClockTimeValue = Value
        if CustomClockTime then
            LightingService.ClockTime = Value
        end
    end
})

Lighting:Toggle({
    Name = "Global Shadows",
    Flag = "GlobalShadows",
    Default = originalGlobalShadows,
    Callback = function(Value)
        LightingService.GlobalShadows = Value
    end
})

local environmentDiffuseToggle = Lighting:Toggle({
    Name = "Custom Environment Diffuse",
    Flag = "CustomEnvironmentDiffuse",
    Default = false,
    Callback = function(Value)
        CustomEnvironmentDiffuse = Value
        if Value then
            LightingService.EnvironmentDiffuseScale = EnvironmentDiffuseValue
        else
            LightingService.EnvironmentDiffuseScale = originalEnvironmentDiffuseScale
        end
    end
})

Lighting:Slider({
    Name = "Environment Diffuse Scale",
    Flag = "EnvironmentDiffuseValue",
    Min = 0,
    Max = 1,
    Default = originalEnvironmentDiffuseScale,
    Decimals = 0.01,
    Callback = function(Value)
        EnvironmentDiffuseValue = Value
        if CustomEnvironmentDiffuse then
            LightingService.EnvironmentDiffuseScale = Value
        end
    end
})

local environmentSpecularToggle = Lighting:Toggle({
    Name = "Custom Environment Specular",
    Flag = "CustomEnvironmentSpecular",
    Default = false,
    Callback = function(Value)
        CustomEnvironmentSpecular = Value
        if Value then
            LightingService.EnvironmentSpecularScale = EnvironmentSpecularValue
        else
            LightingService.EnvironmentSpecularScale = originalEnvironmentSpecularScale
        end
    end
})

Lighting:Slider({
    Name = "Environment Specular Scale",
    Flag = "EnvironmentSpecularValue",
    Min = 0,
    Max = 1,
    Default = originalEnvironmentSpecularScale,
    Decimals = 0.01,
    Callback = function(Value)
        EnvironmentSpecularValue = Value
        if CustomEnvironmentSpecular then
            LightingService.EnvironmentSpecularScale = Value
        end
    end
})

local exposureToggle = Lighting:Toggle({
    Name = "Custom Exposure",
    Flag = "CustomExposure",
    Default = false,
    Callback = function(Value)
        CustomExposure = Value
        if Value then
            LightingService.ExposureCompensation = ExposureValue
        else
            LightingService.ExposureCompensation = originalExposureCompensation
        end
    end
})

Lighting:Slider({
    Name = "Exposure Compensation",
    Flag = "ExposureValue",
    Min = -3,
    Max = 3,
    Default = originalExposureCompensation,
    Decimals = 0.1,
    Callback = function(Value)
        ExposureValue = Value
        if CustomExposure then
            LightingService.ExposureCompensation = Value
        end
    end
})

local colorShiftBottomToggle = Lighting:Toggle({
    Name = "Custom Color Shift Bottom",
    Flag = "CustomColorShiftBottom",
    Default = false,
    Callback = function(Value)
        CustomColorShiftBottom = Value
        if Value then
            LightingService.ColorShift_Bottom = ColorShiftBottomColor
        else
            LightingService.ColorShift_Bottom = originalColorShiftBottom
        end
    end
})

colorShiftBottomToggle:Colorpicker({
    Name = "Color Shift Bottom Color",
    Flag = "ColorShiftBottomColor",
    Default = originalColorShiftBottom,
    Callback = function(Value)
        ColorShiftBottomColor = Value
        if CustomColorShiftBottom then
            LightingService.ColorShift_Bottom = Value
        end
    end
})

local colorShiftTopToggle = Lighting:Toggle({
    Name = "Custom Color Shift Top",
    Flag = "CustomColorShiftTop",
    Default = false,
    Callback = function(Value)
        CustomColorShiftTop = Value
        if Value then
            LightingService.ColorShift_Top = ColorShiftTopColor
        else
            LightingService.ColorShift_Top = originalColorShiftTop
        end
    end
})

colorShiftTopToggle:Colorpicker({
    Name = "Color Shift Top Color",
    Flag = "ColorShiftTopColor",
    Default = originalColorShiftTop,
    Callback = function(Value)
        ColorShiftTopColor = Value
        if CustomColorShiftTop then
            LightingService.ColorShift_Top = Value
        end
    end
})

local geographicLatitudeToggle = Lighting:Toggle({
    Name = "Custom Geographic Latitude",
    Flag = "CustomGeographicLatitude",
    Default = false,
    Callback = function(Value)
        CustomGeographicLatitude = Value
        if Value then
            LightingService.GeographicLatitude = GeographicLatitudeValue
        else
            LightingService.GeographicLatitude = originalGeographicLatitude
        end
    end
})

Lighting:Slider({
    Name = "Geographic Latitude",
    Flag = "GeographicLatitudeValue",
    Min = -90,
    Max = 90,
    Default = originalGeographicLatitude,
    Decimals = 0.1,
    Callback = function(Value)
        GeographicLatitudeValue = Value
        if CustomGeographicLatitude then
            LightingService.GeographicLatitude = Value
        end
    end
})

Lighting:Dropdown({
    Name = "Shadow Mode",
    Items = {"Hard", "Medium", "Soft"},
    Flag = "ShadowMode",
    Default = "Medium",
    Multi = false,
    Callback = function(Value)
        local softness = 0
        if Value == "Hard" then
            softness = 0
        elseif Value == "Medium" then
            softness = 0.5
        elseif Value == "Soft" then
            softness = 1
        end
        LightingService.ShadowSoftness = softness
    end
})

local nebulaToggle = Misc:Toggle({
    Name = "Nebula Theme",
    Flag = "NebulaTheme",
    Default = false,
    Callback = function(state)
        nebulaEnabled = state
        if state then
            local b = Instance.new("BloomEffect", LightingService) b.Intensity, b.Size, b.Threshold, b.Name = 0.7, 24, 1, "NebulaBloom"
            local c = Instance.new("ColorCorrectionEffect", LightingService) c.Saturation, c.Contrast, c.TintColor, c.Name = 0.5, 0.2, nebulaThemeColor, "NebulaColorCorrection"
            local a = Instance.new("Atmosphere", LightingService) a.Density, a.Offset, a.Glare, a.Haze, a.Color, a.Decay, a.Name = 0.4, 0.25, 1, 2, nebulaThemeColor, Color3.fromRGB(25, 25, 112), "NebulaAtmosphere"
            LightingService.Ambient, LightingService.OutdoorAmbient = nebulaThemeColor, nebulaThemeColor
            LightingService.FogStart, LightingService.FogEnd = 100, 500
            LightingService.FogColor = nebulaThemeColor
        else
            for _, v in pairs({"NebulaBloom", "NebulaColorCorrection", "NebulaAtmosphere"}) do
                local obj = LightingService:FindFirstChild(v) if obj then obj:Destroy() end
            end
            LightingService.Ambient, LightingService.OutdoorAmbient = originalAmbient, originalOutdoorAmbient
            LightingService.FogStart, LightingService.FogEnd = originalFogStart, originalFogEnd
            LightingService.FogColor = originalFogColor
        end
    end
})

nebulaToggle:Colorpicker({
    Name = "Nebula Color",
    Flag = "NebulaColor",
    Default = Color3.fromRGB(173, 216, 230),
    Callback = function(c)
        nebulaThemeColor = c
        if nebulaEnabled then
            local nc = LightingService:FindFirstChild("NebulaColorCorrection") if nc then nc.TintColor = c end
            local na = LightingService:FindFirstChild("NebulaAtmosphere") if na then na.Color = c end
            LightingService.Ambient, LightingService.OutdoorAmbient = c, c
            LightingService.FogColor = c
        end
    end
})

local skyboxToggle = Misc:Toggle({
    Name = "Custom Skybox",
    Flag = "CustomSkybox",
    Default = false,
    Callback = function(Value)
        CustomSkybox = Value
        if Value then
            Visuals:SwitchSkybox(SelectedSkybox or "Game's Default Sky")
        else
            Visuals:SwitchSkybox("Game's Default Sky")
        end
    end
})

Misc:Dropdown({
    Name = "Skybox",
    Items = SkyboxNames,
    Flag = "SelectedSkybox",
    Default = "Game's Default Sky",
    Multi = false,
    Callback = function(Value)
        SelectedSkybox = Value
        if CustomSkybox then
            Visuals:SwitchSkybox(Value)
        end
    end
})

Desync = {
    Enabled = false,
    Mode = "Void"
}
AntiLock = {
    Enabled = false,
    Mode = "Custom",
    Custom = { X = 0, Y = 0, Z = 0 },
    Up = { Amount = 0 },
    Down = { Amount = 0 },
    VelMultiply = { Walk = 0, Jump = 0 },
    LookVec = { Amount = 0 },
    Reverse = { Amount = 0, Type = "CFrame" },
    Confusion = { Amount = 0 },
    PredBreaker = false
}

-- === TẠO PART DESYNC ===
local desync_setback = Instance.new("Part")
desync_setback.Name = "DesyncSetback"
desync_setback.Size = Vector3.new(2, 2, 1)
desync_setback.CanCollide = false
desync_setback.Anchored = true
desync_setback.Transparency = 1
desync_setback.Parent = workspace

-- === RESET CAMERA ===
local function resetCamera()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
    end
end

-- === TẠO SUBPAGE + SECTIONS ===
local AntiAimSubPage = ClientPage:SubPage({Name = "Anti Aim", Columns = 2})
local AntiAimSection = AntiAimSubPage:Section({Name = "Anti Aim", Side = 1})
local AntiAimSection2 = AntiAimSubPage:Section({Name = "Anti Aim 2", Side = 2})

-- === UI: DESYNC ===
AntiAimSection:Toggle({
    Name = "Desync",
    Flag = "DesyncEnabled",
    Default = false,
    Callback = function(v)
        DesyncEnabled = v
    end
}):Keybind({
    Default = Enum.KeyCode.V,
    Mode = "Toggle",
    Callback = function()
        DesyncEnabled = not DesyncEnabled
    end
})

AntiAimSection:Dropdown({
    Name = "Desync Mode",
    Flag = "DesyncMode",
    Items = {"Destroy Cheaters", "Underground", "Void Spam", "Void"},
    Default = "Void",
    Multi = false,
    Callback = function(v)
        DesyncMode = v
    end
})

-- === UI: ANTI LOCK ===
AntiAimSection:Toggle({
    Name = "Anti Lock",
    Flag = "AntiLockEnabled",
    Default = false,
    Callback = function(v)
        AntiLockEnabled = v
    end
}):Keybind({
    Default = Enum.KeyCode.B,
    Mode = "Toggle",
    Callback = function()
        AntiLockEnabled = not AntiLockEnabled
    end
})

AntiAimSection:Dropdown({
    Name = "Anti Lock Mode",
    Flag = "AntiLockMode",
    Items = {"Custom", "Up", "Down", "VelMultiply", "LookVec", "Reverse", "Confusion", "PredBreaker"},
    Default = "Custom",
    Multi = false,
    Callback = function(v)
        AntiLockMode = v
    end
})

AntiAimSection:Slider({Name = "X", Flag = "CustomX", Min = -10000, Max = 10000, Default = 0, Callback = function(v) AntiLockCustom.X = v end})
AntiAimSection:Slider({Name = "Y", Flag = "CustomY", Min = -10000, Max = 10000, Default = 0, Callback = function(v) AntiLockCustom.Y = v end})
AntiAimSection:Slider({Name = "Z", Flag = "CustomZ", Min = -10000, Max = 10000, Default = 0, Callback = function(v) AntiLockCustom.Z = v end})

AntiAimSection:Slider({Name = "UpAmount", Flag = "UpAmount", Min = 1, Max = 10000, Default = 100, Callback = function(v) UpAmount = v end})
AntiAimSection2:Slider({Name = "DownAmount", Flag = "DownAmount", Min = 1, Max = 10000, Default = 100, Callback = function(v) DownAmount = v end})
AntiAimSection2:Textbox({Name = "VelWalk", Flag = "VelWalk", Placeholder = "1.5", Callback = function(v) VelMultiply.Walk = tonumber(v) or 0 end})
AntiAimSection2:Textbox({Name = "VelJump", Flag = "VelJump", Placeholder = "1.0", Callback = function(v) VelMultiply.Jump = tonumber(v) or 0 end})
AntiAimSection2:Slider({Name = "LookVecAmt", Flag = "LookVecAmt", Min = 1, Max = 10000, Default = 500, Callback = function(v) LookVecAmount = v end})
AntiAimSection2:Slider({Name = "ReverseAmt", Flag = "ReverseAmt", Min = 1, Max = 10000, Default = 50, Callback = function(v) ReverseAmount = v end})
AntiAimSection2:Dropdown({Name = "ReverseType", Flag = "ReverseType", Items = {"CFrame", "Velocity"}, Default = "CFrame", Callback = function(v) ReverseType = v end})
AntiAimSection2:Slider({Name = "ConfusionAmt", Flag = "ConfusionAmt", Min = 1, Max = 10000, Default = 5, Callback = function(v) ConfusionAmount = v end})

-- === DESYNC LOGIC (Heartbeat) ===
RunService.Heartbeat:Connect(function()
    if not Desync.Enabled or not LocalPlayer.Character then return end
    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local old = hrp.CFrame
    local pos = old.Position

    if Desync.Mode == "Destroy Cheaters" then
        pos = Vector3.new(9e9, 1, 1)
    elseif Desync.Mode == "Underground" then
        pos = pos - Vector3.new(0, 12, 0)
    elseif Desync.Mode == "Void Spam" then
        pos = math.random(1,2) == 1 and old.Position or Vector3.new(math.random(10000,50000), math.random(10000,50000), math.random(10000,50000))
    elseif Desync.Mode == "Void" then
        pos = pos + Vector3.new(math.random(-444444,444444), math.random(-444444,444444), math.random(-44444,44444))
    end

    hrp.CFrame = CFrame.new(pos)
    workspace.CurrentCamera.CameraSubject = desync_setback
    RunService.RenderStepped:Wait()
    desync_setback.CFrame = old * CFrame.new(0, hrp.Size.Y/2 + 0.5, 0)
    hrp.CFrame = old
end)

-- === ANTI LOCK LOGIC (Heartbeat) ===
RunService.Heartbeat:Connect(function()
    if not Enabled or not LocalPlayer.Character then return end
    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not hrp or not hum then return end

    local vel = hrp.Velocity
    local cf = hrp.CFrame
    local S = AntiLock

    if S.Mode == "Custom" and (S.Custom.X ~= 0 or S.Custom.Y ~= 0 or S.Custom.Z ~= 0) then
        hrp.Velocity = Vector3.new(S.Custom.X, S.Custom.Y, S.Custom.Z)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "Up" and S.Up.Amount > 0 then
        hrp.Velocity = Vector3.new(vel.X, S.Up.Amount, vel.Z)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "Down" and S.Down.Amount > 0 then
        hrp.Velocity = Vector3.new(vel.X, -S.Down.Amount, vel.Z)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "VelMultiply" and (S.VelMultiply.Walk > 0 or S.VelMultiply.Jump > 0) then
        hrp.Velocity = vel * Vector3.new(S.VelMultiply.Walk, S.VelMultiply.Jump, S.VelMultiply.Walk)
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "LookVec" and S.LookVec.Amount > 0 then
        hrp.Velocity = cf.lookVector * S.LookVec.Amount
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    elseif S.Mode == "Reverse" and S.Reverse.Amount > 0 then
        if S.Reverse.Type == "CFrame" then
            hrp.CFrame = cf - hum.MoveDirection * (S.Reverse.Amount / 10)
        else
            hrp.Velocity = vel * Vector3.new(-S.Reverse.Amount/2.5, 1, -S.Reverse.Amount/2.5)
            RunService.RenderStepped:Wait()
            hrp.Velocity = vel
        end
    elseif S.Mode == "Confusion" and S.Confusion.Amount > 0 then
        hrp.CFrame = cf * CFrame.new(math.random(1,2)==1 and S.Confusion.Amount or -S.Confusion.Amount, 0, 0)
    elseif S.Mode == "PredBreaker" then
        hrp.Velocity = Vector3.zero
        RunService.RenderStepped:Wait()
        hrp.Velocity = vel
    end
end)

-- === TỰ ĐỘNG RESET CAMERA KHI TẮT DESYNC HOẶC RESPAWN ===
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    resetCamera()
end)

-- Khi tắt Desync
spawn(function()
    while task.wait(0.1) do
        if not Desync.Enabled then
            resetCamera()
        end
    end
end)
--[[local rs = game:GetService("RunService")
local uis = game:GetService("UserInputService")
local lp = game.Players.LocalPlayer
local TweenService = game:GetService("TweenService")

-- Danh sách animation
local animations = {
	M = "http://www.roblox.com/asset/?id=15609995579",
	N = "http://www.roblox.com/asset/?id=14352343065",
	K = "rbxassetid://115730920794562",
}

local currentTrack = nil
local currentKey = nil
local renderConnection = nil
local inputConnection = nil

-- Hàm thiết lập nhân vật
local function setup(char)
	local hum = char:WaitForChild("Humanoid", 5)
	if not hum then return end

	local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

	-- Ngắt kết nối cũ
	if renderConnection then renderConnection:Disconnect() end
	if inputConnection then inputConnection:Disconnect() end

	-- Dừng animation khi di chuyển
	renderConnection = rs.RenderStepped:Connect(function()
		if currentTrack and hum.MoveDirection.Magnitude > 0 then
			currentTrack:Stop()
			currentTrack = nil
			currentKey = nil
		end
	end)

	-- Phát animation khi nhấn phím
	inputConnection = uis.InputBegan:Connect(function(input)
		local key = input.KeyCode.Name
		local animId = animations[key]
		if animId and hum.MoveDirection.Magnitude == 0 then
			if currentTrack then
				currentTrack:Stop()
				currentTrack = nil
				currentKey = nil
			end
			local anim = Instance.new("Animation")
			anim.AnimationId = animId
			local track = animator:LoadAnimation(anim)
			track:Play()
			currentTrack = track
			currentKey = key
		end
	end)
end

-- Kiểm tra character hiện tại
if lp.Character then
	setup(lp.Character)
end

-- Khi nhân vật respawn
lp.CharacterAdded:Connect(function(char)
	currentTrack = nil
	currentKey = nil
	task.wait(0.2)
	setup(char)
end)]]

pcall(function()
    local oldIndex
    local success = pcall(function()
        oldIndex = hookmetamethod(game, "__index", function(self, key)
            if not checkcaller() and self:IsA("Mouse") and (key == "Hit" or key == "Target") then
                if AimEnabled and SilentAimEnabled and 
                   silentTarget and silentAimPosition and math.random(1, 100) <= HitChance then

                    if key == "Hit" then
                        return CFrame.new(silentAimPosition)
                    elseif key == "Target" then
                        return silentTarget.Character:FindFirstChild(HitPart) or silentTarget.Character.HumanoidRootPart
                    end
                end
            end
            return oldIndex(self, key)
        end)
    end)
    if not success then warn("[matcha] Silent Aim hook failed") end
end)

Library:Notification("matcha.tea", "Thank you for using matcha.tea", 5)
