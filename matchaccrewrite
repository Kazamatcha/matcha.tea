local repo = 'https://raw.githubusercontent.com/Kazamatcha/library/refs/heads/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true
Library.ShowCustomCursor = true
Library.NotifySide = "Left"
local TextChatService = game:GetService("TextChatService")

local chatWindow = TextChatService:FindFirstChild("ChatWindowConfiguration")
if chatWindow then
    chatWindow.Enabled = true -- Bật lại chat window
end
local Window = Library:CreateWindow({
    Title = '                                                                               matcha.cc',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = true,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Visual = Window:AddTab('Visual'),
    Character = Window:AddTab('Character'),
    Misc = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local matchacc = {
    TargetAim = {
        Enabled = false,
        Target = "None",
        AutoSelect = false,
        AutoFire = false,
        Strafe = false,
        ToggleStrafe = false,
        VisualizeStrafe = false,
        VisualizeStrafeInlineColor = Color3.new(155/255, 125/255, 175/255),
        VisualizeStrafeOutlineColor = Color3.new(155/255, 125/255, 175/255),
        LineStrafe = false,
        StrafeMethod = "Randomize",
        StrafePrediction = 0.1,
        Highlight = false,
        HighlightFillColor = Color3.new(155/255, 125/255, 175/255),
        HighlightOutlineColor = Color3.new(129/255, 105/255, 145/255),
        Tracer = false,
        TracerPosition = "Mouse",
        TracerFillColor = Color3.new(155/255, 125/255, 175/255),
        TracerOutlineColor = Color3.new(0, 0, 0),
        LookAt = false,
        SpectateTarget = false,
        VoidResolver = false,
        AutoStomp = false,
    },
    HitEffects = {
        HitSounds = false,
        HitSoundID = "rbxassetid://6534947588",
        HitSoundVolume = 5,
        HitNotifications = false,
        HitNotificationsTime = 3,
    },
    Checks = {
        Wall = false,
        Forcefield = false,
        Alive = false,
        Team = false,
    },
    KillAura = {
        Enabled = false,
        Active = false,
        Range = 250,
        Silent = false,
        Visualize = false,
        StompAura = false,
        Whitelist = {},
    },
    RapidFire = {
        Enabled = false,
    },
    Wallbang = {
        Enabled = false,
    },
    HitboxExpander = {
        Enabled = false,
        Visualize = false,
        Color = Color3.new(155/255, 125/255, 175/255),
        OutlineColor = Color3.new(155/255, 125/255, 175/255),
        FillTransparency = 0.5,
        OutlineTransparency = 0.3,
        Size = 15,
    },
    AutoKill = {
        Enabled = false,
        Target = nil,
        Spectate = false,
        AutoKillDesync = true,
    },
    Movement = {
        WalkSpeedEnabled = false,
        WalkSpeed = 16,  -- Default Roblox walkspeed
        JumpPowerEnabled = false,
        JumpPower = 50,  -- Default Roblox jumppower
    },
}

-- BodyClone for Visualize
local BodyClone = game:GetObjects("rbxassetid://8246626421")[1]
BodyClone.Parent = workspace
BodyClone.Humanoid:Destroy()
BodyClone.Head.Face:Destroy()
for _, v in pairs(BodyClone:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("MeshPart") then
        v.CanCollide = false
        v.Transparency = 1
    end
end
BodyClone.HumanoidRootPart.Transparency = 1
BodyClone.HumanoidRootPart.Velocity = Vector3.zero
BodyClone.HumanoidRootPart.CFrame = CFrame.new(9999, 9999, 9999)

local BodyCloneHighlight = Instance.new("Highlight")
BodyCloneHighlight.Enabled = false
BodyCloneHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
BodyCloneHighlight.FillColor = Color3.fromRGB(0, 255, 0)
BodyCloneHighlight.OutlineColor = Color3.fromRGB(255, 255, 255)
BodyCloneHighlight.FillTransparency = 0.3
BodyCloneHighlight.OutlineTransparency = 0
BodyCloneHighlight.Adornee = BodyClone
BodyCloneHighlight.Parent = BodyClone

local GlowLight = Instance.new("PointLight")
GlowLight.Color = Color3.fromRGB(0, 255, 100)
GlowLight.Brightness = 4
GlowLight.Range = 40
GlowLight.Parent = BodyClone.HumanoidRootPart

-- Desync Line
local DesyncLine = Drawing.new("Line")
DesyncLine.Thickness = 1
DesyncLine.Color = Color3.fromRGB(0, 255, 0)
DesyncLine.Visible = false
DesyncLine.Transparency = 1

-- Tracer for TargetAim
local tracerOutline = Drawing.new("Line")
tracerOutline.Visible = false
tracerOutline.Color = matchacc.TargetAim.TracerOutlineColor
tracerOutline.Thickness = 4

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Color = matchacc.TargetAim.TracerFillColor
tracer.Thickness = 2

-- KillAura Tracer Part
local ka_tracer = Instance.new("Part")
ka_tracer.Size = Vector3.new(0.2, 0.2, 0.2)
ka_tracer.Material = Enum.Material.Neon
ka_tracer.Color = Color3.new(1, 0, 0)
ka_tracer.Transparency = 1
ka_tracer.Anchored = true
ka_tracer.CanCollide = false
ka_tracer.Parent = workspace

-- Global Vars
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local UserInputService = game:GetService("UserInputService")
local possibleRemotes = { "MAINEVENT", "MainEvent", "Remote", "Packages", "MainRemotes", "Bullets" }
local function getMainRemote()
    if ReplicatedStorage:FindFirstChild("MainEvent") then return ReplicatedStorage.MainEvent end
    if ReplicatedStorage:FindFirstChild("MAINEVENT") then return ReplicatedStorage.MAINEVENT end
    if ReplicatedStorage:FindFirstChild("Remote") then return ReplicatedStorage.Remote end
    if ReplicatedStorage:FindFirstChild("Bullets") then return ReplicatedStorage.Bullets end
    -- MainRemotes.MainRemoteEvent
    local mainRemotes = ReplicatedStorage:FindFirstChild("MainRemotes")
    if mainRemotes and mainRemotes:FindFirstChild("MainRemoteEvent") then return mainRemotes.MainRemoteEvent end
    -- Packages.Knit.Services.ToolService.RE.UpdateAim
    local packages = ReplicatedStorage:FindFirstChild("Packages")
    if packages then
        local knit = packages:FindFirstChild("Knit")
        if knit and knit:FindFirstChild("Services") then
            local toolService = knit.Services:FindFirstChild("ToolService")
            if toolService and toolService:FindFirstChild("RE") then
                local re = toolService.RE
                if re:FindFirstChild("UpdateAim") then return re.UpdateAim end
            end
        end
    end
    -- fallback: không tìm thấy
    return nil
end

local MainEvent = getMainRemote()
local previousPositions = {}
local customVelocities = {}
local lastTarget = nil
local t = 0
local M1Down = false
local lastHealth = nil
local ka_lastHealth = {}
local hitsounds = {
    ["Bubble"] = "rbxassetid://6534947588",
    ["Lazer"] = "rbxassetid://130791043",
    ["Pick"] = "rbxassetid://1347140027",
    ["Pop"] = "rbxassetid://198598793",
    ["Rust"] = "rbxassetid://1255040462",
    ["Sans"] = "rbxassetid://3188795283",
    ["Fart"] = "rbxassetid://130833677",
    ["Big"] = "rbxassetid://5332005053",
    ["Vine"] = "rbxassetid://5332680810",
    ["UwU"] = "rbxassetid://8679659744",
    ["Bruh"] = "rbxassetid://4578740568",
    ["Skeet"] = "rbxassetid://5633695679",
    ["Neverlose"] = "rbxassetid://6534948092",
    ["Fatality"] = "rbxassetid://6534947869",
    ["Bonk"] = "rbxassetid://5766898159",
    ["Minecraft"] = "rbxassetid://5869422451",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["RIFK7"] = "rbxassetid://9102080552",
    ["Bamboo"] = "rbxassetid://3769434519",
    ["Crowbar"] = "rbxassetid://546410481",
    ["Weeb"] = "rbxassetid://6442965016",
    ["Beep"] = "rbxassetid://8177256015",
    ["Bambi"] = "rbxassetid://8437203821",
    ["Stone"] = "rbxassetid://3581383408",
    ["Old Fatality"] = "rbxassetid://6607142036",
    ["Click"] = "rbxassetid://8053704437",
    ["Ding"] = "rbxassetid://7149516994",
    ["Snow"] = "rbxassetid://6455527632",
    ["Laser"] = "rbxassetid://7837461331",
    ["Mario"] = "rbxassetid://2815207981",
    ["Steve"] = "rbxassetid://4965083997",
    ["Call of Duty"] = "rbxassetid://5952120301",
    ["Bat"] = "rbxassetid://3333907347",
    ["TF2 Critical"] = "rbxassetid://296102734",
    ["Saber"] = "rbxassetid://8415678813",
    ["Baimware"] = "rbxassetid://3124331820",
    ["Osu"] = "rbxassetid://7149255551",
    ["TF2"] = "rbxassetid://2868331684",
    ["Slime"] = "rbxassetid://6916371803",
    ["Among Us"] = "rbxassetid://5700183626",
    ["One"] = "rbxassetid://7380502345"
}

local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end

    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then
            return false
        end
    end

    return true
end

local function KnockCheck(plr)
    if plr and plr.Character and plr.Character:FindFirstChild("BodyEffects") then
        local ko = plr.Character.BodyEffects:FindFirstChild("K.O")
        return ko and ko.Value or false
    end
    return false
end

local function GetClosestCharacter()
    local closestDist = math.huge
    local closestPlayer = nil
    local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in pairs(players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Head") then
            if matchacc.Checks.Team and player.Team == localPlayer.Team then continue end
            if matchacc.Checks.Forcefield and player.Character:FindFirstChild("ForceField") then continue end
            if matchacc.Checks.Alive and not isAlive(player) then continue end

            local headPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(player.Character.Head.Position)
            local dist = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude if isMobile then dist = (player.Character.Head.Position - localPlayer.Character.Head.Position).Magnitude end

            if onScreen and dist < closestDist then
                if matchacc.Checks.Wall then
                    local ray = Ray.new(workspace.CurrentCamera.CFrame.Position, player.Character.Head.Position - workspace.CurrentCamera.CFrame.Position)
                    local hit = workspace:FindPartOnRayWithIgnoreList(ray, {localPlayer.Character})
                    if hit and hit:IsDescendantOf(player.Character) then
                        closestDist = dist
                        closestPlayer = player
                    end
                else
                    closestDist = dist
                    closestPlayer = player
                end
            end
        end
    end
    return closestPlayer
end

local function createHitSound()
    local sound = Instance.new("Sound")
    sound.Parent = localPlayer.Character.HumanoidRootPart
    sound.SoundId = matchacc.HitEffects.HitSoundID
    sound.Volume = matchacc.HitEffects.HitSoundVolume
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

local function SetRigTransparency(clone, trans)
    for _, v in pairs(clone:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("MeshPart") then
            v.Transparency = trans
        end
    end
end

local function SetRigCollisionFalse(clone)
    for _, v in pairs(clone:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("MeshPart") then
            v.CanCollide = false
        end
    end
end

local function SetRigColor(clone, color)
    for _, v in pairs(clone:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("MeshPart") then
            v.Color = color
        end
    end
end

-- UI Setup
local MainTabBox = Tabs.Main:AddLeftTabbox()
local TargetAimTab = MainTabBox:AddTab('Target aim')
local ChecksTab = MainTabBox:AddTab('Checks')

TargetAimTab:AddToggle('TargetAimEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.Enabled = Value
        if not Value then
            matchacc.TargetAim.Target = "None"
            tracer.Visible = false
            tracerOutline.Visible = false
            for _, player in pairs(players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                    player.Character.Highlight:Destroy()
                end
            end
            SetRigTransparency(BodyClone, 1)
            DesyncLine.Visible = false
            BodyCloneHighlight.Enabled = false
            workspace.CurrentCamera.CameraSubject = localPlayer.Character.Humanoid
        end
    end
}):AddKeyPicker('TargetAimKey', {
    Default = 'Q',
    Text = 'Target Aim',
    Mode = 'Toggle',
    Callback = function(Value)
        if not matchacc.TargetAim.Enabled then return end
        if Value then
            local target = GetClosestCharacter()
            if target then
                matchacc.TargetAim.Target = target.Name
            else
                matchacc.TargetAim.Target = "None"
            end
        else
            matchacc.TargetAim.Target = "None"
            tracer.Visible = false
            tracerOutline.Visible = false
            for _, player in pairs(players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                    player.Character.Highlight:Destroy()
                end
            end
            SetRigTransparency(BodyClone, 1)
            DesyncLine.Visible = false
            BodyCloneHighlight.Enabled = false
        end
    end
})

TargetAimTab:AddToggle('AutoSelect', {
    Text = 'Auto Select',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.AutoSelect = Value
        if Value then
            RunService:BindToRenderStep("AutoSelect", 1, function()
                local target = GetClosestCharacter()
                if lastTarget and lastTarget ~= target and lastTarget.Character then
                    local highlight = lastTarget.Character:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                    tracer.Visible = false
                    tracerOutline.Visible = false
                end
                if target then
                    matchacc.TargetAim.Target = target.Name
                else
                    matchacc.TargetAim.Target = "None"
                end
                lastTarget = target
            end)
        else
            RunService:UnbindFromRenderStep("AutoSelect")
            if lastTarget and lastTarget.Character then
                local highlight = lastTarget.Character:FindFirstChild("Highlight")
                if highlight then
                    highlight:Destroy()
                end
                tracer.Visible = false
                tracerOutline.Visible = false
            end
            lastTarget = nil
            for _, player in pairs(players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                    player.Character.Highlight:Destroy()
                end
            end
        end
    end
})

TargetAimTab:AddToggle('AutoFire', {
    Text = 'Auto Fire',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.AutoFire = Value
    end
})

TargetAimTab:AddToggle('Highlight', {
    Text = 'Highlight',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.Highlight = Value
        for _, player in pairs(players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Highlight") and player.Character.Highlight.FillColor == matchacc.TargetAim.HighlightFillColor then
                player.Character.Highlight:Destroy()
            end
        end
    end
}):AddColorPicker('HighlightFill', {
    Default = matchacc.TargetAim.HighlightFillColor,
    Title = 'Fill Color',
    Callback = function(Value)
        matchacc.TargetAim.HighlightFillColor = Value
    end
}):AddColorPicker('HighlightOutline', {
    Default = matchacc.TargetAim.HighlightOutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.TargetAim.HighlightOutlineColor = Value
    end
})

TargetAimTab:AddToggle('Tracer', {
    Text = 'Tracer',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.Tracer = Value
        tracer.Visible = false
        tracerOutline.Visible = false
    end
}):AddColorPicker('TracerFill', {
    Default = matchacc.TargetAim.TracerFillColor,
    Title = 'Fill Color',
    Callback = function(Value)
        matchacc.TargetAim.TracerFillColor = Value
        tracer.Color = Value
    end
}):AddColorPicker('TracerOutline', {
    Default = matchacc.TargetAim.TracerOutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.TargetAim.TracerOutlineColor = Value
        tracerOutline.Color = Value
    end
})

TargetAimTab:AddDropdown('TracerPosition', {
    Values = {'Mouse', 'Tool'},
    Default = 1,
    Multi = false,
    Text = 'Tracer Position',
    Callback = function(Value)
        matchacc.TargetAim.TracerPosition = Value
    end
})

TargetAimTab:AddToggle('LookAt', {
    Text = 'Look At',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.LookAt = Value
    end
})

TargetAimTab:AddToggle('ToggleStrafe', {
    Text = 'Toggle Strafe',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.ToggleStrafe = Value
    end
}):AddKeyPicker('StrafeKey', {
    Default = 'Z',
    Text = 'Strafe',
    Mode = 'Toggle',
    Callback = function(Value)
        if matchacc.TargetAim.ToggleStrafe then
            matchacc.TargetAim.Strafe = Value
            if Value then
                Library:Notify("Strafe: ON", 2)
            else
                Library:Notify("Strafe: OFF", 2)
            end
        end
    end
})

TargetAimTab:AddToggle('VisualizeStrafe', {
    Text = 'Visualize Strafe',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.VisualizeStrafe = Value
    end
}):AddColorPicker('VisInline', {
    Default = matchacc.TargetAim.VisualizeStrafeInlineColor,
    Title = 'Inline Color',
    Callback = function(Value)
        matchacc.TargetAim.VisualizeStrafeInlineColor = Value
        BodyCloneHighlight.FillColor = Value
    end
}):AddColorPicker('VisOutline', {
    Default = matchacc.TargetAim.VisualizeStrafeOutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.TargetAim.VisualizeStrafeOutlineColor = Value
        BodyCloneHighlight.OutlineColor = Value
    end
})

TargetAimTab:AddToggle('LineStrafe', {
    Text = 'Line Strafe',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.LineStrafe = Value
    end
})

TargetAimTab:AddDropdown('StrafeMethod', {
    Values = {'Orbit', 'Randomize'},
    Default = 2,
    Multi = false,
    Text = 'Strafe Method',
    Callback = function(Value)
        matchacc.TargetAim.StrafeMethod = Value
    end
})

TargetAimTab:AddSlider('StrafePrediction', {
    Text = 'Strafe Prediction',
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        matchacc.TargetAim.StrafePrediction = Value
    end
})

TargetAimTab:AddToggle('AutoStomp', {
    Text = 'Auto Stomp',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.AutoStomp = Value
    end
})

TargetAimTab:AddToggle('VoidResolver', {
    Text = 'Void Resolver',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.VoidResolver = Value
    end
})

TargetAimTab:AddToggle('SpectateTarget', {
    Text = 'Spectate Target',
    Default = false,
    Callback = function(Value)
        matchacc.TargetAim.SpectateTarget = Value
    end
}):AddKeyPicker('SpectateKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Spectate Target',
    Callback = function(Value)
        matchacc.TargetAim.SpectateTarget = Value
    end
})
local AutoKillGroup = Tabs.Main:AddLeftGroupbox('Auto Kill')

AutoKillGroup:AddToggle('AutoKillEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.AutoKill.Enabled = Value
    end
}):AddKeyPicker('AutoKillKey', {
    Default = 'none',
    Text = 'Auto Kill',
    Mode = 'Toggle',
    Callback = function(Value)
        matchacc.AutoKill.Enabled = Value
    end
})

AutoKillGroup:AddToggle('AutoKillSpectate', {
    Text = 'Spectate',
    Default = false,
    Callback = function(Value)
        matchacc.AutoKill.Spectate = Value
    end
})

AutoKillGroup:AddDropdown('AutoKillTarget', {
    SpecialType = 'Player',
    Multi = false,
    Text = 'Target',
    Searchable = true,
    Callback = function(Value)
        matchacc.AutoKill.Target = Value
    end
})

AutoKillGroup:AddToggle('AutoKillDesync', {
    Text = 'Desync',
    Default = true,
    Callback = function(Value)
        matchacc.AutoKill.AutoKillDesync = Value
    end
})
local HitEffectsGroup = Tabs.Main:AddLeftGroupbox('Hit Effects')

HitEffectsGroup:AddToggle('HitNotifications', {
    Text = 'Hit Notifications',
    Default = false,
    Callback = function(Value)
        matchacc.HitEffects.HitNotifications = Value
    end
})

HitEffectsGroup:AddSlider('NotifyTime', {
    Text = 'Notify Time',
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(Value)
        matchacc.HitEffects.HitNotificationsTime = Value
    end
})

HitEffectsGroup:AddToggle('HitSounds', {
    Text = 'Hit Sounds',
    Default = false,
    Callback = function(Value)
        matchacc.HitEffects.HitSounds = Value
    end
})

--[[HitEffectsGroup:AddDropdown('HitSoundSelect', {
    Values = table.keys(hitsounds),
    Default = 1,
    Multi = false,
    Text = 'Hit Sound',
    Callback = function(Value)
        matchacc.HitEffects.HitSoundID = hitsounds[Value]
    end
})]]

HitEffectsGroup:AddSlider('HitSoundVolume', {
    Text = 'Volume',
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(Value)
        matchacc.HitEffects.HitSoundVolume = Value
    end
})

ChecksTab:AddToggle('CheckWall', {
    Text = 'Check Wall',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Wall = Value
    end
})

ChecksTab:AddToggle('CheckForcefield', {
    Text = 'Check Forcefield',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Forcefield = Value
    end
})

ChecksTab:AddToggle('CheckAlive', {
    Text = 'Check Alive',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Alive = Value
    end
})

ChecksTab:AddToggle('CheckTeam', {
    Text = 'Check Team',
    Default = false,
    Callback = function(Value)
        matchacc.Checks.Team = Value
    end
})

local KillAuraGroup = Tabs.Main:AddRightGroupbox('Kill Aura')

KillAuraGroup:AddToggle('KillAuraEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.Enabled = Value
        if not Value then
            matchacc.KillAura.Active = false
            ka_tracer.Transparency = 1
        end
    end
}):AddKeyPicker('KillAuraKey', {
    Default = 'K',
    Text = 'Kill Aura',
    Mode = 'Toggle',
    Callback = function(Value)
        if matchacc.KillAura.Enabled then
            matchacc.KillAura.Active = Value
        end
    end
})

KillAuraGroup:AddSlider('KillAuraRange', {
    Text = 'Range',
    Default = 250,
    Min = 10,
    Max = 250,
    Rounding = 0,
    Callback = function(Value)
        matchacc.KillAura.Range = Value
    end
})

KillAuraGroup:AddToggle('KillAuraSilent', {
    Text = 'Silent',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.Silent = Value
    end
})

KillAuraGroup:AddToggle('KillAuraVisualize', {
    Text = 'Visualize',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.Visualize = Value
    end
}):AddColorPicker('KAVisColor', {
    Default = Color3.new(1, 0, 0),
    Title = 'Visualizer Color',
    Callback = function(Value)
        ka_tracer.Color = Value
    end
})

KillAuraGroup:AddDropdown('KAWhitelist', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Multi = true,
    Searchable = true,
    Text = 'Whitelist',
    Callback = function(Value)
        matchacc.KillAura.Whitelist = Value
    end
})

KillAuraGroup:AddToggle('StompAura', {
    Text = 'Stomp Aura',
    Default = false,
    Callback = function(Value)
        matchacc.KillAura.StompAura = Value
    end
})

local MovementGroup = Tabs.Character:AddLeftGroupbox('Movement')

matchacc.Movement = {
    Speed = {
        Enabled = false,
        Keybind = false,
        Speed = 20,
    },
    Fly = {
        Enabled = false,
        Keybind = false,
        Speed = 20,
    },
}

MovementGroup:AddToggle('SpeedEnabled', {
    Text = 'Speed Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.Speed.Enabled = Value
    end
}):AddKeyPicker('SpeedKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Speed Key',
    Callback = function(Value)
        matchacc.Movement.Speed.Keybind = Value
    end
})

MovementGroup:AddSlider('SpeedValue', {
    Text = 'Speed',
    Default = 20,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.Speed.Speed = Value
    end
})

MovementGroup:AddToggle('FlyEnabled', {
    Text = 'Fly Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.Fly.Enabled = Value
    end
}):AddKeyPicker('FlyKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Fly Key',
    Callback = function(Value)
        matchacc.Movement.Fly.Keybind = Value
    end
})

MovementGroup:AddSlider('FlySpeed', {
    Text = 'Fly Speed',
    Default = 20,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.Fly.Speed = Value
    end
})

-- WalkSpeed
MovementGroup:AddToggle('WalkSpeedToggle', {
    Text = 'Walk Speed',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.WalkSpeedEnabled = Value
    end
}):AddKeyPicker('WalkSpeedKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Walk Speed'
})

MovementGroup:AddSlider('WalkSpeedSlider', {
    Text = 'Speed',
    Default = 16,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.WalkSpeed = Value
    end
})

-- JumpPower
MovementGroup:AddToggle('JumpPowerToggle', {
    Text = 'Jump Power',
    Default = false,
    Callback = function(Value)
        matchacc.Movement.JumpPowerEnabled = Value
    end
}):AddKeyPicker('JumpPowerKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Jump Power'
})

MovementGroup:AddSlider('JumpPowerSlider', {
    Text = 'Power',
    Default = 50,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        matchacc.Movement.JumpPower = Value
    end
})

-- Loop set WalkSpeed và JumpPower liên tục (thêm vào script, sau UI setup)
RunService.Heartbeat:Connect(function()
    local hum = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        if matchacc.Movement.WalkSpeedEnabled then
            hum.WalkSpeed = matchacc.Movement.WalkSpeed
        end
        if matchacc.Movement.JumpPowerEnabled then
            hum.JumpPower = matchacc.Movement.JumpPower
            hum.UseJumpPower = true  -- Đảm bảo dùng JumpPower
        end
    end
end)

-- Reset khi character respawn (thêm vào CharacterAdded)
localPlayer.CharacterAdded:Connect(function(char)
    StopFly()  -- Reset fly nếu đang bật
    task.wait(1)  -- Chờ character load
    if matchacc.Movement.FlyEnabled then StartFly() end
end)
-- Integrate Movement Logic into Heartbeat
RunService.Heartbeat:Connect(function(dt)
    -- Speed
    if matchacc.Movement.Speed.Enabled and matchacc.Movement.Speed.Keybind then
        if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local move_direction = localPlayer.Character.Humanoid.MoveDirection
            local hrp = localPlayer.Character.HumanoidRootPart
            hrp.CFrame = hrp.CFrame + (move_direction * dt) * matchacc.Movement.Speed.Speed * 10
        end
    end
    
    -- Fly
    if matchacc.Movement.Fly.Enabled and matchacc.Movement.Fly.Keybind then
        if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local move_direction = localPlayer.Character.Humanoid.MoveDirection
            local hrp = localPlayer.Character.HumanoidRootPart
            local add = Vector3.new(0, (UserInputService:IsKeyDown(Enum.KeyCode.Space) and matchacc.Movement.Fly.Speed / 8 or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and -matchacc.Movement.Fly.Speed / 8) or 0, 0)
            hrp.CFrame = hrp.CFrame + (move_direction * dt) * matchacc.Movement.Fly.Speed * 10
            hrp.CFrame = hrp.CFrame + add
            hrp.Velocity = (hrp.Velocity * Vector3.new(1, 0, 1)) + Vector3.new(0, 1.9, 0)
        end
    end
end) 
--logic
if getnamecallmethod then 
    local Meta = getrawmetatable(game)
    local backupindex = Meta.__index
    setreadonly(Meta, false)

    Meta.__index = function(t, k)
        if k:lower() == "hit" then
            if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" and localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
                if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and not TargetPlayer.Character:FindFirstChild("ForceField") then
                    if not KnockCheck(TargetPlayer) then
                        return TargetPlayer.Character.Head.CFrame
                    end
                end
            end
        end
        return backupindex(t, k)
    end
end
if getnamecallmethod and game.GameId == 9825515356 then
    local OldNamecall
    OldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local method = getnamecallmethod()

        if method == "FireServer" and self.Name == "MainEvent" and args[1] == "Shoot" then
            if matchacc.TargetAim.Enabled and matchacc.TargetAim.AutoFire and matchacc.TargetAim.Target ~= "None" and localPlayer and localPlayer.Character then
                local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
                if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and not TargetPlayer.Character:FindFirstChild("ForceField") then
                    if not KnockCheck(TargetPlayer) then
                        local TargetPart = TargetPlayer.Character.Head
                        if TargetPart and args[2] then
                            for _, info in pairs(args[2][1]) do
                                info["Instance"] = TargetPart
                            end
                            for _, info in pairs(args[2][2]) do
                                info["thePart"] = TargetPart
                                info["theOffset"] = CFrame.new()
                            end
                            return OldNamecall(self, unpack(args))
                        end
                    end
                end
            end
        end

        return OldNamecall(self, ...)
    end)
end
RunService.Heartbeat:Connect(function(dt)
    if matchacc.AutoKill.Enabled then
        if matchacc.AutoKill.Target ~= nil then
            local Target = players:FindFirstChild(matchacc.AutoKill.Target)
            
            if Target and Target.Character and localPlayer and localPlayer.Character then
                local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                local head = localPlayer.Character:FindFirstChild("Head")
                local tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                local toolHandle = tool and tool:FindFirstChild("Handle")
                local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                local targetHead = Target.Character:FindFirstChild("Head")

                local SavedPosition = localPlayer.Character.HumanoidRootPart.CFrame

                if humanoidRootPart and head and toolHandle and targetHRP and targetHead then
                    if not KnockCheck(Target) then
                        if not Target.Character:FindFirstChild("ForceField") then
                            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.lookAt(Target.Character.Head.Position + Vector3.new(math.random(-15,15), math.random(-15,15), math.random(-15,15)), Target.Character.Head.Position)
                            Library:Notify("Matcha.cc - Shooting Target.", 1)
                            MainEvent:FireServer("ShootGun", toolHandle, toolHandle.Position, Target.Character.Head.Position, targetHead, Vector3.new(0, 1, 0))
                        else
                            localPlayer.Character.HumanoidRootPart.CFrame += Vector3.new(math.random(-80000,80000), math.random(0,80000), math.random(-80000,80000))
                            Library:Notify("Matcha.cc - Waiting.. Target has spawn protection.", 1)
                            MainEvent:FireServer("Reload", tool)
                        end
                        if matchacc.AutoKill.AutoKillDesync then
                            RunService:BindToRenderStep("RestoreCFrame", 199, function()
                                localPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
                                RunService:UnbindFromRenderStep("RestoreCFrame")
                            end)
                        end
                    else
                        -- Handle dead targets
                        local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
                        local isDead = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects.SDeath.Value
                        if isDead == false then
                            if Target.Character:FindFirstChild("UpperTorso") and Target.Character:FindFirstChild("HumanoidRootPart") and Target.Character:FindFirstChild("Humanoid") then
                                humanoidRootPart.CFrame = CFrame.new(Target.Character.UpperTorso.Position + Vector3.new(0, 3, 0))
                                Library:Notify("Matcha.cc - Stomping Target.", 1)
                                MainEvent:FireServer("Stomp")
                            end
                        elseif isDead == true then
                            -- Move to safe position when target is dead
                            localPlayer.Character.HumanoidRootPart.CFrame += Vector3.new(math.random(-80000,80000), math.random(0,80000), math.random(-80000,80000))
                            Library:Notify("Matcha.cc - Waiting.. Target is currently dead.", 1)
                            MainEvent:FireServer("Reload", tool)
                        end

                        if matchacc.AutoKill.AutoKillDesync then
                            RunService:BindToRenderStep("RestoreCFrame", 199, function()
                                localPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
                                RunService:UnbindFromRenderStep("RestoreCFrame")
                            end)
                        end

                    end
                else
                    -- If gun is not equipped
                    localPlayer.Character.HumanoidRootPart.CFrame += Vector3.new(math.random(-80000,80000), math.random(0,80000), math.random(-80000,80000))
                    Library:Notify("Matcha.cc - Waiting.. Equip your gun while using 'Auto Kill Target'.", 1)

                    if matchacc.AutoKill.AutoKillDesync then
                        RunService:BindToRenderStep("RestoreCFrame", 199, function()
                            localPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
                            RunService:UnbindFromRenderStep("RestoreCFrame")
                        end)
                    end
                end
            end
        else
            -- If no target is found
            local humanoidRootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                humanoidRootPart.CFrame = CFrame.new(0, 500, 0)
            end
            Library:Notify("Matcha.cc - Target not found.", 3)
        end
    end
    if matchacc.AutoKill.Spectate and matchacc.AutoKill.Target and matchacc.AutoKill.Target.Character and matchacc.AutoKill.Target.Character:FindFirstChildOfClass("Humanoid") then
        workspace.CurrentCamera.CameraSubject = matchacc.AutoKill.Target.Character.Humanoid
    else
        workspace.CurrentCamera.CameraSubject = localPlayer.Character:FindFirstChildOfClass("Humanoid") or localPlayer.Character.Humanoid
    end
end)
-- Mouse1 Down Detect
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        M1Down = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        M1Down = false
    end
end)

local pingvalue = nil
local split = nil
local ping = nil
local PredictionValue = nil

local GlobalPredictionMultiplier = 0.80

local basePredictionTable = {
    {ping = 130, value = 0.51},
    {ping = 125, value = 0.49},
    {ping = 110, value = 0.46},
    {ping = 105, value = 0.38},
    {ping = 90,  value = 0.36},
    {ping = 80,  value = 0.34},
    {ping = 70,  value = 0.31},
    {ping = 60,  value = 0.229},
    {ping = 50,  value = 0.225},
    {ping = 40,  value = 0.256}
}
local previousKnock = false
local previousDead = false
local lastTargetCharacter = nil

-- Thêm event PlayerRemoving (sau MainEvent = getMainRemote())
players.PlayerRemoving:Connect(function(plr)
    if plr.Name == matchacc.TargetAim.Target then
        Library:Notify(plr.Name .. " left the game", 3)
        matchacc.TargetAim.Target = "None"
        previousKnock = false
        previousDead = false
        lastTargetCharacter = nil
    end
end)
game:GetService("RunService").Stepped:Connect(function()
    pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
    split = string.split(pingvalue, '(')
    ping = tonumber(split[1])

    for _, data in ipairs(basePredictionTable) do
        if ping < data.ping then
            PredictionValue = data.value * GlobalPredictionMultiplier
            break
        end
    end
end)
if getnamecallmethod and matchacc.RapidFire.Enabled then
    local tool = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool:FindFirstChild("GunScript") then 
        for _, v in ipairs(getconnections(tool.Activated)) do
            local funcinfo = debug.getinfo(v.Function)
            for i = 1, funcinfo.nups do
                local c, n = debug.getupvalue(v.Function, i)
                if type(c) == "number" then 
                    debug.setupvalue(v.Function, i, 0)
                end
            end
        end
    end
end
RunService.Heartbeat:Connect(function(dt)
    local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
    local useDesync = matchacc.TargetAim.Strafe or matchacc.TargetAim.AutoStomp or matchacc.KillAura.StompAura 
    local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
    local SavedPosition = hrp.CFrame
    if useDesync and hrp then
        if matchacc.TargetAim.Strafe and matchacc.TargetAim.Target ~= "None" and TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") then
            if not TargetPlayer.Character:FindFirstChild("ForceField") then
                if not KnockCheck(TargetPlayer) and localPlayer.Character.BodyEffects.Reload.Value == false then
                    if matchacc.TargetAim.VoidResolver and (TargetPlayer.Character.HumanoidRootPart.Position - Vector3.new(0, 0, 0)).Magnitude > 5000 then return end
                    local currentPosition = TargetPlayer.Character.Head.Position
                    local lastPosition = previousPositions[TargetPlayer] or currentPosition
                    local estimatedVelocity = (currentPosition - lastPosition) / dt
                    local alpha = 0.5
                    customVelocities[TargetPlayer] = (customVelocities[TargetPlayer] or Vector3.zero) * alpha + estimatedVelocity * (1 - alpha)
                    previousPositions[TargetPlayer] = currentPosition
                    local strafeOffset
                    if matchacc.TargetAim.StrafeMethod == "Orbit" then
                        strafeOffset = Vector3.new(math.cos(tick()*10)*10, 0, math.sin(tick()*10)*10)
                    elseif matchacc.TargetAim.StrafeMethod == "Randomize" then
                        strafeOffset = Vector3.new(math.random(-15,15), math.random(-15,15), math.random(-15,15))
                    end
                    local desyncPosition = currentPosition + (customVelocities[TargetPlayer] * PredictionValue) + strafeOffset
                    hrp.CFrame = CFrame.lookAt(desyncPosition, currentPosition)
                    if matchacc.TargetAim.VisualizeStrafe then
                        BodyClone:SetPrimaryPartCFrame(hrp.CFrame)
                        BodyCloneHighlight.Enabled = true
                        SetRigTransparency(BodyClone, 0)
                        SetRigColor(BodyClone, matchacc.TargetAim.VisualizeStrafeInlineColor)
                        BodyCloneHighlight.FillColor = matchacc.TargetAim.VisualizeStrafeInlineColor
                        BodyCloneHighlight.OutlineColor = matchacc.TargetAim.VisualizeStrafeOutlineColor
                    else
                        BodyCloneHighlight.Enabled = false
                        BodyClone:SetPrimaryPartCFrame(CFrame.new(9999, 9999, 9999))
                        SetRigTransparency(BodyClone, 1)
                    end
                    if matchacc.TargetAim.LineStrafe and matchacc.TargetAim.VisualizeStrafe then
                        local rootPos = hrp.Position
                        local clonePos = BodyClone.HumanoidRootPart.Position
                        local screen1, onScreen1 = workspace.CurrentCamera:WorldToViewportPoint(rootPos)
                        local screen2, onScreen2 = workspace.CurrentCamera:WorldToViewportPoint(clonePos)
                        if onScreen1 and onScreen2 then
                            DesyncLine.From = Vector2.new(screen1.X, screen1.Y)
                            DesyncLine.To = Vector2.new(screen2.X, screen2.Y)
                            DesyncLine.Color = BodyCloneHighlight.FillColor
                            DesyncLine.Visible = true
                        else
                            DesyncLine.Visible = false
                        end
                    else
                        DesyncLine.Visible = false
                    end
                    local PredictedAimingPosition = currentPosition + (customVelocities[TargetPlayer] * PredictionValue)
                    local args = {
                        [1] = "ShootGun",
                        [2] = Tool.Handle,
                        [3] = Tool.Handle.Position,
                        [4] = PredictedAimingPosition,
                        [5] = TargetPlayer.Character.Head,
                        [6] = Vector3.new(0, 0, 0)
                    }
                    if matchacc.TargetAim.AutoFire then
                        MainEvent:FireServer(unpack(args))
                    elseif M1Down then
                        MainEvent:FireServer(unpack(args))
                    end
                    RunService:BindToRenderStep("RestoreStrafe", 199, function()
                        hrp.CFrame = SavedPosition
                        RunService:UnbindFromRenderStep("RestoreStrafe")
                    end)
                end
            else
                hrp.CFrame += Vector3.new(math.random(-80000,80000), math.random(0,80000), math.random(-80000,80000))
                RunService:BindToRenderStep("RestoreRandom", 199, function()
                    hrp.CFrame = SavedPosition
                    RunService:UnbindFromRenderStep("RestoreRandom")
                end)
            end
        elseif TargetPlayer.Character:FindFirstChild("ForceField") or not Tool then
            hrp.CFrame += Vector3.new(math.random(-80000,80000), math.random(0,80000), math.random(-80000,80000))
            RunService:BindToRenderStep("RestoreForceField", 199, function()
                hrp.CFrame = SavedPosition
                RunService:UnbindFromRenderStep("RestoreForceField")
            end)
        end
    else
        BodyClone:SetPrimaryPartCFrame(CFrame.new(9999, 9999, 9999))
        BodyCloneHighlight.Enabled = false
        DesyncLine.Visible = false
        ka_tracer.Transparency = 1
        workspace.CurrentCamera.CameraSubject = localPlayer.Character.Humanoid
    end
    if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" and TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") and not KnockCheck(TargetPlayer) then
        local tool = localPlayer.Character:FindFirstChildOfClass("Tool")
        if tool and (not TargetPlayer.Character:FindFirstChild("ForceField") or tool.Name == "[Rifle]") then
            if matchacc.TargetAim.AutoFire then
                if game.PlaceId == 9825515356 then
                    local args = {
                        "Shoot",
                        {
                            {
                                [1] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = Vector3.new(-141.78562927246094, 33.89368438720703, -365.6424865722656)
                                },
                                [2] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = Vector3.new(-141.78562927246094, 33.89368438720703, -365.6424865722656)
                                },
                                [3] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937343597412109, 0.10944879800081253, -0.022651422768831253),
                                    ["Position"] = TargetPlayer.Character.Head.Position 
                                },
                                [4] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = TargetPlayer.Character.Head.Position 
                                },
                                [5] = {
                                    ["Instance"] = TargetPlayer.Character.Head,
                                    ["Normal"] = Vector3.new(0.9937344193458557, 0.10944880545139313, -0.022651424631476402),
                                    ["Position"] = Vector3.new(-141.79481506347656, 34.033607482910156, -365.369384765625)
                                }
                            },
                            {
                                [1] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [2] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [3] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [4] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                },
                                [5] = {
                                    ["thePart"] = TargetPlayer.Character.Head,
                                    ["theOffset"] = CFrame.new(0, 0, 0)
                                }
                            },
                            localPlayer.Character.Head.Position,
                            localPlayer.Character.Head.Position,
                            workspace:GetServerTimeNow()
                        }
                    }
                    MainEvent:FireServer(unpack(args))
                else
                    local args = {
                        [1] = "ShootGun",
                        [2] = tool.Handle,
                        [3] = tool.Handle.Position,
                        [4] = TargetPlayer.Character.Head.Position,
                        [5] = TargetPlayer.Character.Head,
                        [6] = Vector3.new(0, 0, 0)
                    }
                    MainEvent:FireServer(unpack(args))
                end
            elseif M1Down then
                local args = {
                    [1] = "ShootGun",
                    [2] = tool.Handle,
                    [3] = tool.Handle.Position,
                    [4] = TargetPlayer.Character.Head.Position,
                    [5] = TargetPlayer.Character.Head,
                    [6] = Vector3.new(0, 0, 0)
                }
                MainEvent:FireServer(unpack(args))
            end
        end
    end
end)
RunService.Heartbeat:Connect(function(dt)
    local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
    local useDesync = matchacc.TargetAim.Strafe or matchacc.TargetAim.AutoStomp or matchacc.KillAura.StompAura 
    local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
    local SavedPosition = hrp.CFrame
    if matchacc.KillAura.Enabled then
        if Tool and Tool:FindFirstChild("Handle") then
            if localPlayer.Character.BodyEffects:FindFirstChild("K.O") and not localPlayer.Character.BodyEffects["K.O"].Value then
                local closest = math.huge
                local ka_target = nil
                for _, player in pairs(players:GetPlayers()) do
                    if player ~= localPlayer and not matchacc.KillAura.Whitelist[player.Name] and player.Character and player.Character:FindFirstChild("Head") and not player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
                        if player.Character.BodyEffects:FindFirstChild("K.O") and not player.Character.BodyEffects["K.O"].Value then
                            local dist = (hrp.Position - player.Character.Head.Position).Magnitude
                            if dist < closest and dist <= matchacc.KillAura.Range then
                                closest = dist
                                ka_target = player
                            end
                        end
                    end
                end
                if ka_target and ka_target.Character and ka_target.Character:FindFirstChild("Head") then
                    hrp.CFrame = CFrame.lookAt(hrp.Position, ka_target.Character.Head.Position)
                    if matchacc.KillAura.Visualize then
                        ka_tracer.Transparency = 0
                        ka_tracer.Size = Vector3.new(0.2, 0.2, (hrp.Position - ka_target.Character.Head.Position).Magnitude)
                        ka_tracer.CFrame = CFrame.lookAt(hrp.Position, ka_target.Character.Head.Position) * CFrame.new(0, 0, -ka_tracer.Size.Z / 2)
                    else
                        ka_tracer.Transparency = 1
                    end
                    local humanoid = ka_target.Character:FindFirstChild("Humanoid")
                    if humanoid then
                        if not ka_lastHealth[ka_target.Name] then
                            ka_lastHealth[ka_target.Name] = humanoid.Health
                        end
                        if humanoid.Health < ka_lastHealth[ka_target.Name] then
                            createHitSound()
                        end
                        ka_lastHealth[ka_target.Name] = humanoid.Health
                    end
                    local offset = matchacc.KillAura.Silent and Vector3.new(0, -12, 0) or Vector3.new(0, 0, 0)
                    MainEvent:FireServer(
                        "ShootGun",
                        Tool:FindFirstChild("Handle"),
                        Tool:FindFirstChild("Handle").CFrame.Position + offset,
                        ka_target.Character.Head.Position + offset,
                        ka_target.Character.Head,
                        Vector3.new(0, 0, -1)
                    )
                else
                    ka_tracer.Transparency = 1
                end
            end
        else
            ka_tracer.Transparency = 1
        end
    end
    if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" then
        local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
        if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Humanoid") and TargetPlayer.Character:FindFirstChild("Head") and not TargetPlayer.Character:FindFirstChild("ForceField") then
            local humanoid = TargetPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                local currentHealth = math.round(humanoid.Health)
                if lastHealth == nil or matchacc.TargetAim.Target ~= lastTarget then
                    lastHealth = currentHealth
                end
                if currentHealth < lastHealth then
                    if matchacc.HitEffects.HitNotifications then
                        Library:Notify("Matcha.cc - Target Hit: " .. TargetPlayer.Name .. " - Health: " .. currentHealth, matchacc.HitEffects.HitNotificationsTime)
                    end
                    if matchacc.HitEffects.HitSounds then
                        createHitSound()
                    end
                end
                lastHealth = currentHealth
                lastTarget = matchacc.TargetAim.Target
            end
        end
    end
    if matchacc.TargetAim.Enabled and matchacc.TargetAim.Target ~= "None" and TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Head") then
        if matchacc.TargetAim.Highlight then
            if not TargetPlayer.Character:FindFirstChild("Highlight") then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = TargetPlayer.Character
            end
            TargetPlayer.Character.Highlight.FillColor = matchacc.TargetAim.HighlightFillColor
            TargetPlayer.Character.Highlight.OutlineColor = matchacc.TargetAim.HighlightOutlineColor
        end
        if matchacc.TargetAim.LookAt then
            localPlayer.Character.Humanoid.AutoRotate = false
            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.lookAt(localPlayer.Character.HumanoidRootPart.Position, Vector3.new(TargetPlayer.Character.HumanoidRootPart.Position.X, localPlayer.Character.HumanoidRootPart.Position.Y, TargetPlayer.Character.HumanoidRootPart.Position.Z))
        else
            localPlayer.Character.Humanoid.AutoRotate = true
        end
        if matchacc.TargetAim.Tracer then
            local mouseScreenPosition = UserInputService:GetMouseLocation()
            local head = TargetPlayer.Character:FindFirstChild("Head")
            local humanoidRootPart = TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if head and humanoidRootPart then
                local headScreenPosition, onScreen = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local adjustedMousePosition = Vector2.new(mouseScreenPosition.X, mouseScreenPosition.Y)
                    local tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                    if matchacc.TargetAim.TracerPosition == "Tool" and tool and tool:FindFirstChild("Handle") then
                        local pos = workspace.CurrentCamera:WorldToViewportPoint(tool.Handle.Position)
                        tracer.From = Vector2.new(pos.X, pos.Y)
                        tracerOutline.From = Vector2.new(pos.X, pos.Y)
                    else
                        tracer.From = adjustedMousePosition
                        tracerOutline.From = adjustedMousePosition
                    end           
                    tracer.To = Vector2.new(headScreenPosition.X, headScreenPosition.Y)
                    tracerOutline.To = Vector2.new(headScreenPosition.X, headScreenPosition.Y)
                    tracerOutline.Visible = true
                    tracer.Visible = true
                    tracerOutline.Color = matchacc.TargetAim.TracerOutlineColor
                    tracer.Color = matchacc.TargetAim.TracerFillColor
                else
                    tracer.Visible = false
                    tracerOutline.Visible = false
                end
            end
        end
        if matchacc.TargetAim.SpectateTarget and TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChildOfClass("Humanoid") then
            workspace.CurrentCamera.CameraSubject = TargetPlayer.Character.Humanoid
        else
            workspace.CurrentCamera.CameraSubject = localPlayer.Character:FindFirstChildOfClass("Humanoid") or localPlayer.Character.Humanoid
        end
    else
        localPlayer.Character.Humanoid.AutoRotate = true
        tracer.Visible = false
        tracerOutline.Visible = false
        workspace.CurrentCamera.CameraSubject = localPlayer.Character.Humanoid
    end
    if matchacc.TargetAim.Target ~= "None" then
        local TargetPlayer = players:FindFirstChild(matchacc.TargetAim.Target)
        if TargetPlayer then
            if TargetPlayer.Character ~= lastTargetCharacter and lastTargetCharacter then
                Library:Notify(TargetPlayer.Name .. " respawned", 3)
                previousKnock = false
                previousDead = false
            end
            lastTargetCharacter = TargetPlayer.Character
            if TargetPlayer.Character then
                local be = TargetPlayer.Character:FindFirstChild("BodyEffects")
                if be then
                    local ko = be:FindFirstChild("K.O")
                    local sdeath = be:FindFirstChild("SDeath")
                    local hum = TargetPlayer.Character:FindFirstChildOfClass("Humanoid")
                    local currentKnock = ko and ko.Value or false
                    local currentDead = (sdeath and sdeath.Value) or (hum and hum.Health <= 0) or false
                    if currentKnock and not previousKnock then
                        Library:Notify(TargetPlayer.Name .. " knocked", 3)
                    end
                    if currentDead and not previousDead then
                        Library:Notify(TargetPlayer.Name .. " died", 3)
                    end
                    previousKnock = currentKnock
                    previousDead = currentDead
                end
            end
        else
            Library:Notify(matchacc.TargetAim.Target .. " left the game", 3)
            matchacc.TargetAim.Target = "None"
            previousKnock = false
            previousDead = false
            lastTargetCharacter = nil
        end
    end
    if not useDesync or hrp then 
        BodyClone:SetPrimaryPartCFrame(CFrame.new(9999, 9999, 9999))
        BodyCloneHighlight.Enabled = false
        DesyncLine.Visible = false
        ka_tracer.Transparency = 1
        workspace.CurrentCamera.CameraSubject = localPlayer.Character.Humanoid
    end
    if useDesync and hrp then
        if matchacc.TargetAim.AutoStomp and TargetPlayer and KnockCheck(TargetPlayer) and localPlayer.Character.BodyEffects.Reload.Value == false then
            local bodyEffects = TargetPlayer.Character:FindFirstChild("BodyEffects")
            local isDead = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects.SDeath.Value
            if isDead == false then
                hrp.CFrame = CFrame.new(TargetPlayer.Character.UpperTorso.Position + Vector3.new(0, 3, 0))
                if matchacc.HitEffects.HitNotifications then
                    if tick() - t >= 3 then
                        t = tick()
                        Library:Notify("Matcha.cc - Attempted to Stomp Target: " .. TargetPlayer.Name, matchacc.HitEffects.HitNotificationsTime)
                    end
                end
                MainEvent:FireServer("Stomp")
                RunService:BindToRenderStep("RestoreStomp", 199, function()
                    hrp.CFrame = SavedPosition
                    RunService:UnbindFromRenderStep("RestoreStomp")
                end)
            end
        elseif matchacc.KillAura.StompAura then
            local shortestDistance = math.huge
            local stompTarget
            for _, player in pairs(players:GetPlayers()) do
                if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Head") and KnockCheck(player) and not player.Character:FindFirstChild("ForceField") then
                    local distance = (player.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    if distance <= matchacc.KillAura.Range and distance < shortestDistance then
                        shortestDistance = distance
                        stompTarget = player
                    end
                end
            end
            if stompTarget then
                local bodyEffects = stompTarget.Character:FindFirstChild("BodyEffects")
                local isDead = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects.SDeath.Value
                if isDead == false then
                    hrp.CFrame = CFrame.new(stompTarget.Character.UpperTorso.Position + Vector3.new(0, 3, 0))
                    MainEvent:FireServer("Stomp")
                    RunService:BindToRenderStep("RestoreStompAura", 199, function()
                        hrp.CFrame = SavedPosition
                        RunService:UnbindFromRenderStep("RestoreStompAura")
                    end)
                end
            end
        end
    end
end)
local RS = cloneref(game:GetService("RunService"))
local Client = players.LocalPlayer
local highlights = {}

RS.RenderStepped:Connect(function()
    if matchacc.HitboxExpander.Enabled then
        for _, Player in pairs(players:GetPlayers()) do
            if Player == Client then continue end
            local HRP = Player.Character and Player.Character:WaitForChild("HumanoidRootPart")
            if HRP then
                HRP.Size = Vector3.new(matchacc.HitboxExpander.Size, matchacc.HitboxExpander.Size, matchacc.HitboxExpander.Size)
                HRP.CanCollide = false
                if matchacc.HitboxExpander.Visualize then
                    if not highlights[Player] then
                        local Visualize = Instance.new("Highlight")
                        HRP.Transparency = 0.9
                        Visualize.Parent = HRP
                        Visualize.FillColor = matchacc.HitboxExpander.Color
                        Visualize.OutlineColor = matchacc.HitboxExpander.OutlineColor
                        Visualize.FillTransparency = matchacc.HitboxExpander.FillTransparency
                        Visualize.OutlineTransparency = matchacc.HitboxExpander.OutlineTransparency
                        highlights[Player] = Visualize
                    else
                        local Visualize = highlights[Player]
                        HRP.Transparency = 0.9
                        Visualize.FillColor = matchacc.HitboxExpander.Color
                        Visualize.OutlineColor = matchacc.HitboxExpander.OutlineColor
                        Visualize.FillTransparency = matchacc.HitboxExpander.FillTransparency
                        Visualize.OutlineTransparency = matchacc.HitboxExpander.OutlineTransparency
                    end
                else
                    local Visualize = highlights[Player]
                    if Visualize then
                        Visualize:Destroy()
                        HRP.Transparency = 1
                        highlights[Player] = nil
                    end
                end
            end
        end
    end
end)
local GunModsGroup = Tabs.Main:AddRightGroupbox('Gun Mods')
matchacc.EquipAllGuns = {
    Enabled = false,
}

-- Globals (sau các global vars khác)
local EquipAllConnection = nil
local lastEquipTime = 0

local function equipAllGuns()
    local char = localPlayer.Character
    local backpack = localPlayer.Backpack
    if not char or not backpack then return end
    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
            tool.Parent = char
        end
    end
end

-- Sửa setupEquipAll và event tương ứng
local function setupEquipAll()
    local char = localPlayer.Character
    if not char or not matchacc.EquipAllGuns.Enabled then return end
    equipAllGuns()
    if EquipAllConnection then
        EquipAllConnection:Disconnect()
    end
    EquipAllConnection = char.ChildRemoved:Connect(function(child)
        if child:IsA("Tool") and child:FindFirstChild("Ammo") and (tick() - lastEquipTime) >= 0.5 then
            lastEquipTime = tick()
            task.spawn(function()
                task.wait(0.1)
                equipAllGuns()
            end)
        end
    end)
end

-- Character respawn
localPlayer.CharacterAdded:Connect(function()
    task.wait(5)
    if matchacc.EquipAllGuns.Enabled then
        setupEquipAll()
    end
end)

-- Thêm vào GunModsGroup (sau Wallbang)
GunModsGroup:AddToggle('EquipAllGunsEnabled', {
    Text = 'Equip All Guns',
    Default = false,
    Callback = function(Value)
        matchacc.EquipAllGuns.Enabled = Value
        if Value then
            setupEquipAll()
        else
            if EquipAllConnection then
                EquipAllConnection:Disconnect()
                EquipAllConnection = nil
            end
        end
    end
}):AddKeyPicker('EquipAllGunsKey', {
    Default = 'none',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Equip All Guns'
})
GunModsGroup:AddToggle('RapidFireEnabled', {
    Text = 'Rapid Fire',
    Default = false,
    Callback = function(Value)
        matchacc.RapidFire.Enabled = Value
    end
})

GunModsGroup:AddToggle('WallbangEnabled', {
    Text = 'Wallbang',
    Default = false,
    Callback = function(Value)
        matchacc.Wallbang.Enabled = Value
        if getnamecallmethod then
            local Handler = game:FindService("ReplicatedStorage").MainModule
            local Module = require(Handler)
            if Value == true and workspace:FindFirstChild("Vehicles") then
                Module.Ignored = {workspace:WaitForChild("Vehicles"), workspace:WaitForChild("MAP"), workspace:WaitForChild("Ignored")}
            else
                if workspace:FindFirstChild("Vehicles") then
                    Module.Ignored = {workspace:WaitForChild("Vehicles"), workspace:WaitForChild("Ignored")}
                end
            end
        else
            Library:Notify("Your executor does not support this feature.", 3)
        end
    end
})
local HitboxGroup = Tabs.Main:AddRightGroupbox('Hitbox Expander')

HitboxGroup:AddToggle('HitboxEnabled', {
    Text = 'Enabled',
    Default = false,
    Callback = function(Value)
        matchacc.HitboxExpander.Enabled = Value
    end
})

HitboxGroup:AddToggle('HitboxVisualize', {
    Text = 'Visualize',
    Default = false,
    Callback = function(Value)
        matchacc.HitboxExpander.Visualize = Value
    end
}):AddColorPicker('HitboxColor', {
    Default = matchacc.HitboxExpander.Color,
    Title = 'Fill Color',
    Callback = function(Value)
        matchacc.HitboxExpander.Color = Value
    end
}):AddColorPicker('HitboxOutline', {
    Default = matchacc.HitboxExpander.OutlineColor,
    Title = 'Outline Color',
    Callback = function(Value)
        matchacc.HitboxExpander.OutlineColor = Value
    end
})

HitboxGroup:AddSlider('HitboxFillTrans', {
    Text = 'Fill Transparency',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        matchacc.HitboxExpander.FillTransparency = Value
    end
})

HitboxGroup:AddSlider('HitboxOutlineTrans', {
    Text = 'Outline Transparency',
    Default = 0.3,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        matchacc.HitboxExpander.OutlineTransparency = Value
    end
})

HitboxGroup:AddSlider('HitboxSize', {
    Text = 'Size',
    Default = 15,
    Min = 1,
    Max = 37,
    Rounding = 0,
    Callback = function(Value)
        matchacc.HitboxExpander.Size = Value
    end
})

-- UI Settings Setup
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddToggle("KeybindMenuOpen", { Default = Library.KeybindFrame.Visible, Text = "Open Keybind Menu", Callback = function(value) Library.KeybindFrame.Visible = value end})
MenuGroup:AddToggle("ShowCustomCursor", {Text = "Custom Cursor", Default = true, Callback = function(Value) Library.ShowCustomCursor = Value end})
MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
MenuGroup:AddButton("Unload", function() Library:Unload() end)
getgenv().vu = game:GetService("VirtualUser")
getgenv().isAntiAfkEnabled = false
getgenv().antiAfkConnection = nil

MenuGroup:AddToggle('AntiAFKToggle', {
    Text = 'Anti-AFK',
    Default = false,
    Tooltip = 'Prevent AFK timeout',
    Callback = function(state)
        getgenv().isAntiAfkEnabled = state
        if getgenv().isAntiAfkEnabled then
            getgenv().antiAfkConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                getgenv().vu:CaptureController()
                getgenv().vu:ClickButton2(Vector2.new())
            end)
        else
            if getgenv().antiAfkConnection then
                getgenv().antiAfkConnection:Disconnect()
                getgenv().antiAfkConnection = nil
            end
        end
    end,
    Disabled = false,
    Visible = true
})

MenuGroup:AddButton({
    Text = 'Copy Job ID',
    Func = function()
        setclipboard(game.JobId)
    end,
    Tooltip = 'Copy the current server Job ID to clipboard',
    DoubleClick = false,
    Disabled = false,
    Visible = true
})
MenuGroup:AddButton({
    Text = 'Copy JS Join Script',
    Func = function()
        local jsScript = 'Roblox.GameLauncher.joinGameInstance(' .. game.PlaceId .. ', "' .. game.JobId .. '")'
        setclipboard(jsScript)
    end,
    Tooltip = 'Copy the join script for the current server',
    DoubleClick = false,
    Disabled = false,
    Visible = true
})
MenuGroup:AddInput('JobIdInput', {
    Default = '',
    Numeric = false,
    Finished = true,
    Text = '..JobId..',
    Tooltip = 'Enter a Job ID to join a specific server',
    Placeholder = 'Enter Job ID here',
    ClearTextOnFocus = true,
    Callback = function(Value)
        game:GetService('TeleportService'):TeleportToPlaceInstance(game.PlaceId, Value, game:GetService('Players').LocalPlayer)
    end,
    Disabled = false,
    Visible = true
})
MenuGroup:AddButton({
    Text = 'Rejoin Server',
    Func = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
    end,
    Tooltip = 'Rejoin the current server',
    DoubleClick = false,
    Disabled = false,
    Visible = true
})
Library:SetWatermarkVisibility(true)
getgenv().matcha = {}
getgenv().matcha.WatermarkEnabled = true
getgenv().matcha.WatermarkShowFPS = true
getgenv().matcha.WatermarkShowGameName = false
getgenv().matcha.WatermarkShowUptime = false
getgenv().matcha.WatermarkShowExecutor = false
getgenv().matcha.WatermarkShowPing = true
local Stats = game:GetService("Stats")
-- Modified Watermark Logic
local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60
local StartTime = tick()

local function getExecutor()
    if syn then return "Synapse X" end
    if secure_call then return "ScriptWare" end
    if identifyexecutor then return identifyexecutor() end
    return "Unknown"
end
local MarketplaceService = game:GetService("MarketplaceService")
local function getGameName(placeId)
    local success, result = pcall(function()
        return MarketplaceService:GetProductInfo(placeId).Name
    end)
    return success and result or "Unknown Game"
end

local function updateWatermark()
    FrameCounter += 1
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    local Ping = math.floor(Stats.Network.ServerStatsItem["Data Ping"]:GetValue())
    local Executor = getExecutor()
    local Uptime = math.floor(tick() - StartTime)
    local UptimeFormatted = string.format("%02d:%02d", math.floor(Uptime / 60), Uptime % 60)
    local GameName = getGameName(game.PlaceId)

    local watermarkParts = {"matcha.tea", " Anhchangm52 "}
    
    if getgenv().matcha.WatermarkShowExecutor then
        table.insert(watermarkParts, Executor)
    end
    if getgenv().matcha.WatermarkShowGameName then
        table.insert(watermarkParts, string.format("%s (%d)", GameName, game.PlaceId))
    end
    if getgenv().matcha.WatermarkShowUptime then
        table.insert(watermarkParts, string.format("Uptime: %s", UptimeFormatted))
    end
    if getgenv().matcha.WatermarkShowFPS then
        table.insert(watermarkParts, string.format("FPS %d", math.floor(FPS)))
    end
    if getgenv().matcha.WatermarkShowPing then
        table.insert(watermarkParts, string.format("%d ms", Ping))
    end

    Library:SetWatermark(table.concat(watermarkParts, " | "))
    Library:SetWatermarkVisibility(getgenv().matcha.WatermarkEnabled)
end

local WatermarkConnection = RunService.RenderStepped:Connect(updateWatermark)


-- Watermark Customization UI
local WatermarkGroup = Tabs['UI Settings']:AddRightGroupbox('Watermark')

WatermarkGroup:AddToggle('WatermarkEnabled', {
    Text = 'Enabled',
    Default = true,
    Callback = function(Value)
        getgenv().matcha.WatermarkEnabled = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowFPS', {
    Text = 'Show FPS',
    Default = true,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowFPS = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowGameName', {
    Text = 'Show Game Name',
    Default = false,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowGameName = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowUptime', {
    Text = 'Show Uptime',
    Default = false,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowUptime = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowExecutor', {
    Text = 'Show Executor',
    Default = false,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowExecutor = Value
    end
})

WatermarkGroup:AddToggle('WatermarkShowPing', {
    Text = 'Show Ping',
    Default = true,
    Callback = function(Value)
        getgenv().matcha.WatermarkShowPing = Value
    end
})

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('matchacc')
SaveManager:SetFolder('matchacc/dahood')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()
Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    print('Unloaded!')
    Library.Unloaded = true
end)
