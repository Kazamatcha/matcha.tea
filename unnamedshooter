--// MATCHA UNNAMED - SIMPLE SILENT AIM + CHAMS + TARGET UI \\--
getgenv().matchaunnamed = {
    Enabled = true,
    Chams = true,
    TargetStats = true,
}

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local TweenService      = game:GetService("TweenService")
local CoreGui           = game:GetService("CoreGui")
local Workspace         = game:GetService("Workspace")
local Camera            = Workspace.CurrentCamera
local LocalPlayer       = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RaycastModule = require(ReplicatedStorage:WaitForChild("Events"):WaitForChild("Modules"):WaitForChild("RaycastModule"))

--// C√ÄI ƒê·∫∂T \\--
local AIM_FOV      = 85
local PREDICTION   = 0.045
local MATCHA_DARK  = Color3.fromRGB(120, 180, 100)  -- Outline
local MATCHA_LIGHT = Color3.fromRGB(180, 230, 160)  -- Fill (nh·∫°t h∆°n)

--// TARGET \\--
local CurrentTarget = nil

local function GetClosestTarget()
    local Closest, Shortest = nil, math.huge
    local CamPos = Camera.CFrame.Position
    local CamLook = Camera.CFrame.LookVector
    local Center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    for _, Player in ipairs(Players:GetPlayers()) do
        if Player == LocalPlayer or (Player.Team and Player.Team == LocalPlayer.Team) then continue end
        local Char = Player.Character
        if not Char or not Char:FindFirstChild("Head") then continue end
        local Head = Char.Head
        local Hum = Char:FindFirstChildOfClass("Humanoid")
        if not Hum or Hum.Health <= 0 then continue end

        local Dir = (Head.Position - CamPos).Unit
        local Angle = math.deg(math.acos(CamLook:Dot(Dir)))
        if Angle > AIM_FOV then continue end

        local ScreenPos, OnScreen = Camera:WorldToViewportPoint(Head.Position)
        if not OnScreen then continue end

        local Dist = (Vector2.new(ScreenPos.X, ScreenPos.Y) - Center).Magnitude
        if Dist < Shortest then
            Shortest = Dist
            Closest = Head
            CurrentTarget = Player
        end
    end
    return Closest
end

--// SILENT AIM HOOK \\--
for i, f in pairs(RaycastModule) do
    if typeof(f) == "function" then
        RaycastModule[i] = function(...)
            if not getgenv().matchaunnamed.Enabled then return f(...) end
            local TargetHead = GetClosestTarget()
            if not TargetHead then 
                CurrentTarget = nil
                return f(...) 
            end
            local Predicted = TargetHead.Position + (TargetHead.Parent:FindFirstChild("HumanoidRootPart") and TargetHead.Parent.HumanoidRootPart.Velocity * PREDICTION or Vector3.new(0,0,0))
            return TargetHead, Predicted, Vector3.zero
        end
    end
end

--// CHAMS (Highlight) \\--
local BLUE_TEAM_OUTLINE = Color3.fromRGB(0, 120, 255)   -- outline team m√¨nh
local BLUE_TEAM_FILL    = Color3.fromRGB(135, 206, 250) -- inline team m√¨nh

local function UpdateChams()
    for _, Player in ipairs(Players:GetPlayers()) do
        if Player == LocalPlayer then continue end
        
        local Char = Player.Character
        if not Char then continue end
        
        -- L·∫•y highlight n·∫øu c√≥
        local HL = Char:FindFirstChild("MatchaHighlight")

        if getgenv().matchaunnamed.Chams then
            
            -- N·∫øu ch∆∞a c√≥ highlight th√¨ t·∫°o
            if not HL then
                HL = Instance.new("Highlight")
                HL.Name = "MatchaHighlight"
                HL.Adornee = Char
                HL.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                HL.Parent = Char
            end

            -- TEAM CHECK
            local sameTeam = false
            if Player.Team and LocalPlayer.Team then
                sameTeam = (Player.Team == LocalPlayer.Team)
            end

            if sameTeam then
                -- TEAM M√åNH
                HL.OutlineColor = BLUE_TEAM_OUTLINE
                HL.FillColor    = BLUE_TEAM_FILL
            else
                -- TEAM ƒê·ªäCH (m·∫∑c ƒë·ªãnh matcha)
                HL.OutlineColor = MATCHA_DARK
                HL.FillColor    = MATCHA_LIGHT
            end

            HL.FillTransparency = 0.7
            HL.OutlineTransparency = 0.25

        else
            -- N·∫øu t·∫Øt Chams th√¨ x√≥a highlight
            if HL then HL:Destroy() end
        end
    end
end

RunService.Heartbeat:Connect(UpdateChams)

--// TARGET STATS GUI \\--
local StatsGui = Instance.new("ScreenGui")
StatsGui.Name = "Matcha_TargetStats"
StatsGui.ResetOnSpawn = false
StatsGui.Parent = CoreGui

local Frame = Instance.new("Frame", StatsGui)
Frame.Size = UDim2.new(0, 300, 0, 70)
Frame.Position = UDim2.new(0.5, 0, 0.95, 0)
Frame.AnchorPoint = Vector2.new(0.5, 1)
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Frame.BackgroundTransparency = 0.4
Frame.BorderSizePixel = 0
Frame.Visible = false
local Corner = Instance.new("UICorner", Frame)
Corner.CornerRadius = UDim.new(0, 12)

local Label = Instance.new("TextLabel", Frame)
Label.Size = UDim2.new(1, -16, 1, -16)
Label.Position = UDim2.new(0, 8, 0, 8)
Label.BackgroundTransparency = 1
Label.TextColor3 = Color3.fromRGB(200, 255, 190)
Label.Font = Enum.Font.Code
Label.TextSize = 16
Label.TextXAlignment = Enum.TextXAlignment.Center
Label.Text = ""

RunService.Heartbeat:Connect(function()
    if getgenv().matchaunnamed.TargetStats and CurrentTarget and CurrentTarget.Character then
        local Hum = CurrentTarget.Character:FindFirstChildOfClass("Humanoid")
        if Hum then
            Frame.Visible = true
            Label.Text = string.format("üéØ %s\n‚ù§Ô∏è %d / %d", CurrentTarget.Name, math.floor(Hum.Health), Hum.MaxHealth)
        else
            Frame.Visible = false
        end
    else
        Frame.Visible = false
    end
end)
local UserInputService = game:GetService("UserInputService")

--// UI \\--
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MatchaUnnamed_UI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

local function CreateButton(name, pos, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0, 120, 0, 44)
    Button.Position = pos
    Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    Button.Text = name
    Button.TextColor3 = Color3.fromRGB(220, 255, 200)
    Button.Font = Enum.Font.Code
    Button.TextSize = 15
    Button.Parent = ScreenGui

    local Corner = Instance.new("UICorner", Button)
    Corner.CornerRadius = UDim.new(0, 10)

    local Shadow = Instance.new("Frame", Button)
    Shadow.Size = UDim2.new(1, 6, 1, 6)
    Shadow.Position = UDim2.new(0, -3, 0, -3)
    Shadow.BackgroundColor3 = Color3.fromRGB(120, 180, 100)
    Shadow.BackgroundTransparency = 0.6
    Shadow.ZIndex = Button.ZIndex - 1
    
    local ShadowCorner = Instance.new("UICorner", Shadow)
    ShadowCorner.CornerRadius = UDim.new(0, 10)

    local Active = getgenv().matchaunnamed[name:gsub(" ", "")] or false

    local function Update()
        TweenService:Create(Shadow, TweenInfo.new(0.3), {
            BackgroundColor3 = Active and Color3.fromRGB(100, 220, 140) or Color3.fromRGB(120, 180, 100)
        }):Play()
    end
    Update()

    Button.MouseButton1Click:Connect(function()
        -- Ch·∫∑n click khi v·ª´a k√©o (mobile/pc)
        if dragging then return end

        Active = not Active
        getgenv().matchaunnamed[name:gsub(" ", "")] = Active
        Update()
        if callback then callback(Active) end
    end)

    ------------------------------------------------------------
    ---------------------- DRAG FIXED ---------------------------
    ------------------------------------------------------------
    dragging = false
    local dragStart, startPos

    Button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or 
           input.UserInputType == Enum.UserInputType.Touch then
            
            dragging = true
            dragStart = UserInputService:GetMouseLocation()
            startPos = Button.Position
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or 
                         input.UserInputType == Enum.UserInputType.Touch) then

            local delta = UserInputService:GetMouseLocation() - dragStart
            Button.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)

    return Button
end

-- T·∫°o c√°c n√∫t
CreateButton("Silent Aim", UDim2.new(0, 20, 0, 20), function(state) getgenv().matchaunnamed.Enabled = state end)
CreateButton("Chams",      UDim2.new(0, 20, 0, 80), function(state) getgenv().matchaunnamed.Chams = state end)
CreateButton("Target UI",  UDim2.new(0, 20, 0, 140), function(state) getgenv().matchaunnamed.TargetStats = state end)

print("Matcha Unnamed - Loaded ‚ô°")