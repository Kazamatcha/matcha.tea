--// MATCHA UNNAMED - SIMPLE SILENT AIM + CHAMS + TARGET UI \\--
getgenv().matchaunnamed = {
    Enabled = true,
    Chams = true,
    TargetStats = true,
}

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local TweenService      = game:GetService("TweenService")
local CoreGui           = game:GetService("CoreGui")
local Workspace         = game:GetService("Workspace")
local Camera            = Workspace.CurrentCamera
local LocalPlayer       = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RaycastModule = require(ReplicatedStorage:WaitForChild("Events"):WaitForChild("Modules"):WaitForChild("RaycastModule"))

--// C√ÄI ƒê·∫∂T \\--
local AIM_FOV      = 85
local PREDICTION   = 0.045
local MATCHA_DARK  = Color3.fromRGB(120, 180, 100)  -- Outline
local MATCHA_LIGHT = Color3.fromRGB(180, 230, 160)  -- Fill (nh·∫°t h∆°n)

--// TARGET \\--
local CurrentTarget = nil

local function GetClosestTarget()
    local Closest, Shortest = nil, math.huge
    local CamPos = Camera.CFrame.Position
    local CamLook = Camera.CFrame.LookVector
    local Center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    for _, Player in ipairs(Players:GetPlayers()) do
        if Player == LocalPlayer or (Player.Team and Player.Team == LocalPlayer.Team) then continue end
        local Char = Player.Character
        if not Char or not Char:FindFirstChild("Head") then continue end
        local Head = Char.Head
        local Hum = Char:FindFirstChildOfClass("Humanoid")
        if not Hum or Hum.Health <= 0 then continue end

        local Dir = (Head.Position - CamPos).Unit
        local Angle = math.deg(math.acos(CamLook:Dot(Dir)))
        if Angle > AIM_FOV then continue end

        local ScreenPos, OnScreen = Camera:WorldToViewportPoint(Head.Position)
        if not OnScreen then continue end

        local Dist = (Vector2.new(ScreenPos.X, ScreenPos.Y) - Center).Magnitude
        if Dist < Shortest then
            Shortest = Dist
            Closest = Head
            CurrentTarget = Player
        end
    end
    return Closest
end

--// SILENT AIM HOOK \\--
for i, f in pairs(RaycastModule) do
    if typeof(f) == "function" then
        RaycastModule[i] = function(...)
            if not getgenv().matchaunnamed.Enabled then return f(...) end
            local TargetHead = GetClosestTarget()
            if not TargetHead then 
                CurrentTarget = nil
                return f(...) 
            end
            local Predicted = TargetHead.Position + (TargetHead.Parent:FindFirstChild("HumanoidRootPart") and TargetHead.Parent.HumanoidRootPart.Velocity * PREDICTION or Vector3.new(0,0,0))
            return TargetHead, Predicted, Vector3.zero
        end
    end
end

--// CHAMS (Highlight) \\--
local function UpdateChams()
    for _, Player in ipairs(Players:GetPlayers()) do
        if Player == LocalPlayer or (Player.Team and Player.Team == LocalPlayer.Team) then continue end
        local Char = Player.Character
        if Char then
            if getgenv().matchaunnamed.Chams then
                for _, Part in ipairs(Char:GetDescendants()) do
                    if Part:IsA("BasePart") and Part.Name ~= "HumanoidRootPart" then
                        if not Part:FindFirstChild("MatchaChamsOutline") then
                            local outline = Instance.new("BoxHandleAdornment")
                            outline.Name = "MatchaChamsOutline"
                            outline.Adornee = Part
                            outline.AlwaysOnTop = true
                            outline.ZIndex = 10
                            outline.Size = Part.Size + Vector3.new(0.1, 0.1, 0.1)
                            outline.Color3 = MATCHA_DARK
                            outline.Transparency = 0.5
                            outline.Parent = Part
                        end
                        if not Part:FindFirstChild("MatchaChamsFill") then
                            local fill = Instance.new("BoxHandleAdornment")
                            fill.Name = "MatchaChamsFill"
                            fill.Adornee = Part
                            fill.AlwaysOnTop = false
                            fill.ZIndex = 5
                            fill.Size = Part.Size
                            fill.Color3 = MATCHA_LIGHT
                            fill.Transparency = 0.7
                            fill.Parent = Part
                        end
                    end
                end
            else
                for _, v in ipairs(Char:GetDescendants()) do
                    if v.Name == "MatchaChamsOutline" or v.Name == "MatchaChamsFill" then
                        v:Destroy()
                    end
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(UpdateChams)

--// TARGET STATS GUI \\--
local StatsGui = Instance.new("ScreenGui")
StatsGui.Name = "Matcha_TargetStats"
StatsGui.ResetOnSpawn = false
StatsGui.Parent = CoreGui

local Frame = Instance.new("Frame", StatsGui)
Frame.Size = UDim2.new(0, 300, 0, 70)
Frame.Position = UDim2.new(0.5, 0, 0.95, 0)
Frame.AnchorPoint = Vector2.new(0.5, 1)
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Frame.BackgroundTransparency = 0.4
Frame.BorderSizePixel = 0
Frame.Visible = false

local Corner = Instance.new("UICorner", Frame)
Corner.CornerRadius = UDim.new(0, 12)

local Label = Instance.new("TextLabel", Frame)
Label.Size = UDim2.new(1, -16, 1, -16)
Label.Position = UDim2.new(0, 8, 0, 8)
Label.BackgroundTransparency = 1
Label.TextColor3 = Color3.fromRGB(200, 255, 190)
Label.Font = Enum.Font.Code
Label.TextSize = 16
Label.TextXAlignment = Enum.TextXAlignment.Center
Label.Text = ""

RunService.Heartbeat:Connect(function()
    if getgenv().matchaunnamed.TargetStats and CurrentTarget and CurrentTarget.Character then
        local Hum = CurrentTarget.Character:FindFirstChildOfClass("Humanoid")
        if Hum then
            Frame.Visible = true
            Label.Text = string.format("üéØ %s\n‚ù§Ô∏è %d / %d", CurrentTarget.Name, math.floor(Hum.Health), Hum.MaxHealth)
        else
            Frame.Visible = false
        end
    else
        Frame.Visible = false
    end
end)

--// UI \\--
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MatchaUnnamed_UI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

local function CreateButton(name, pos, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0, 120, 0, 44)
    Button.Position = pos
    Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    Button.Text = name
    Button.TextColor3 = Color3.fromRGB(220, 255, 200)
    Button.Font = Enum.Font.Code
    Button.TextSize = 15
    Button.Parent = ScreenGui

    local Corner = Instance.new("UICorner", Button)
    Corner.CornerRadius = UDim.new(0, 10)

    local Shadow = Instance.new("Frame", Button)
    Shadow.Size = UDim2.new(1, 6, 1, 6)
    Shadow.Position = UDim2.new(0, -3, 0, -3)
    Shadow.BackgroundColor3 = Color3.fromRGB(120, 180, 100)
    Shadow.BackgroundTransparency = 0.6
    Shadow.ZIndex = Button.ZIndex - 1
    local ShadowCorner = Instance.new("UICorner", Shadow)
    ShadowCorner.CornerRadius = UDim.new(0, 10)

    local Active = getgenv().matchaunnamed[name:gsub(" ", "")] or false

    local function Update()
        TweenService:Create(Shadow, TweenInfo.new(0.3), {
            BackgroundColor3 = Active and Color3.fromRGB(100, 220, 140) or Color3.fromRGB(120, 180, 100)
        }):Play()
    end
    Update()

    Button.MouseButton1Click:Connect(function()
        Active = not Active
        getgenv().matchaunnamed[name:gsub(" ", "")] = Active
        Update()
        if callback then callback(Active) end
    end)

    -- Drag
    local dragging, dragStart, startPos
    Button.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = inp.Position
            startPos = Button.Position
        end
    end)
    Button.InputChanged:Connect(function(inp)
        if dragging and (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) then
            local delta = inp.Position - dragStart
            Button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    Button.InputEnded:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    return Button
end

-- T·∫°o c√°c n√∫t
CreateButton("Silent Aim", UDim2.new(0, 20, 0, 20), function(state) getgenv().matchaunnamed.Enabled = state end)
CreateButton("Chams",      UDim2.new(0, 20, 0, 80), function(state) getgenv().matchaunnamed.Chams = state end)
CreateButton("Target UI",  UDim2.new(0, 20, 0, 140), function(state) getgenv().matchaunnamed.TargetStats = state end)

print("Matcha Unnamed - Loaded ‚ô°")